- **Intro**
  - What is this doc?
  - Who is it for?
  - What does it cover?
- **Dependencies**
  - bitflags
  - bitvec
  - rand, rand\_xoshiro
  - sdl2 (with "image" feature)
  - serde, serde\_json
  - shipyard
  - wyhash
- **Source code layout**
  - It's around 13K SLOC.
  - Most of this won't make sense; see further for context.
  - `assets/` - font and tile images
  - `src/` - game-specific files, quick overview of each file
  - `src/lib/` - game-agnostic files, quick overview of each file
  - `src/modes/` - mode stack implementation and every mode, describe each file starting with mod.rs
- **How stuff works**
  - No engine (unless SDL2 counts) and no roguelike helper libraries.
  - *Overall game flow*
  - *Game loop*
  - *The mode stack*
    - Avoiding the all-encompassing state machine from the Rust roguelike tutorial.
    - ModeResults, or how to handle responses from menus and dialog boxes.
  - *Input queue*
  - *Rendering and display using TileGrids*
    - Overarching rendering strategy
      - Describe software rendering for tile-based graphics.
      - Describe hardware rendering of tile-based graphics with a texture altassing approach.
      - Describe RuggRogue's choice: hybrid rendering.
        - Reasons:
          - Separates drawing tile grid contents from how it's displayed on screen (easier positioning + zoom).
          - Pure SDL-based drawing lets SDL choose the best graphics API for its environment.
        - Probably not the fastest it could be, but it seems reasonably fast compared to naive per-tile drawing.
    - TileGrids and TileGridLayers
      - Everything shown by RuggRogue is a TileGrid.
      - Main game loop inits and draws TileGridLayers; essentially a scene graph.
      - Mode stack ensures that each mode gets its own fresh TileGridLayer.
      - Modes can create as many TileGrids as they need within their TileGridLayer.
    - Tilesets: black-and-white conversion, tall vertical surface for cache-friendliness during rendering.
    - The phases of drawing: draw, render, upload, display.
      - Draw: The TileGrid drawing API, implementations mostly passed off to RawTileGrid.
      - Render: Check for changed tiles with RawTileGrids, draw changed tiles.
      - Upload: Single SDL call to do this.
      - Display: Each TileGrid copies itself to the canvas, while main game loop uses SDL to present it all.
    - Improving render performance with wrapped offset rendering.
    - Improving map draw performance with chunked drawing.
  - *User interface*
    - Mode breakdown with YesNoDialogMode as an example.
    - Layout and drawing of the main game screen.
    - The AppQuit event.
  - *Word wrapping*
  - *Entity Component System*
    - How Shipyard is used.
    - RuggRogue uses Shipyard 0.4:
      - Couldn't use Shipyard 0.5 since a transitive dependency broke the web build.
      - 0.4 API differs from 0.5, so it needs to be covered, since 0.4 docs are no longer online.
    - The World
      - Worlds hold uniques and entities with attached components.
      - Creating a world: `World::new`
    - Uniques
      - What is a unique?
      - Adding a unique to the world: `World::add_unique`
      - Accessing uniques: `UniqueView` and `UniqueViewMut`, with examples using `World::borrow`
      - Shipyard 0.4 has no way to delete or replace uniques.
    - Entities and Components
      - What are entities and components?
      - Creating entities: `EntitiesViewMut` and `EntitiesViewMut::add_entity`
      - Removing entities: `AllStoragesViewMut` and `AllStoragesViewMut::delete`
      - Adding components to entities: `EntitiesView` and `EntitiesView::add_component`
      - Deleting components from entities: `ViewMut::delete`
      - Accessing components of a single entity: `View` and `ViewMut` with the `Shipyard::Get` trait
      - Iterating entities that share components: `Shipyard::IntoIter::iter` and `Shipyard::Shiperator::with_id`
      - Using `EntityId` as a handle to an entity
      - Checking if an entity has a component: `View::contains` and `View::try_get`
    - Avoiding systems
      - `World::run` sometimes appears instead of `World::borrow`
      - RuggRogue prefers `World::borrow` for fine-grained control over references.
        - Rust: One mutable reference or multiple immutable references only.
          - Why it helps: data consistency, use screen tearing as an analogy.
      - Shipyard grants references and checks rules at runtime.
        - Lifetimes of most game data depends on player actions, so many of these checks must be at runtime.
          - Leaf functions still use Rust's compile-time checking.
      - Problem: can't `World::run` within `World::run`.
      - Problem: calling a system within a system, using simplified player spawning as an example.
      - Problem: views claimed too early, causing helper functions to panic.
      - All of these problems are from calling functions within functions.
        - Personal style.
        - Using Shipyard's *workloads* runs systems without nesting, embracing the full ECS style.
          - Couldn't use workloads because runs multi-threaded only, which doesn't work in the web build.
  - *Game data* (Entity life cycle)
    - The world, and which entities exist and when.
    - Despawning entities, including entities they refer to.
  - *Save and load*
    - Overview of saving and loading in the context of the rest of the game.
    - The save file format, with a simple example.
    - Handling of EntityIds during saving and loading.
    - Run-length encoding, used to compress map tile data and field of view bits.
    - Save support for the web version.
  - *Field of view*
    - Introduction to vision:
      - Player only sees their immediate surroundings and can't see through walls.
      - As player moves, game maintains memory of previously seen tiles.
      - This is field of view.
      - Main purpose: Create a sense of exploring the unknown.
    - Applications of field of view:
      - Vision for the player and monsters with the `FieldOfView` component.
      - Determining valid target tiles when using an item at range.
      - Calculating affected tiles from the epicenter of an item used with an `AreaOfEffect` component.
    - Shadow Casting
      - Definition: Starting from a center tile, visit only visible tiles while skipping tiles in shadows created by obstructing tiles closer to the center tile.
      - Faster than ray casting (briefly define ray casting).
      - Distinct from permissive field of view (link RogueBasin) in that shadow casting considers visibility only from the center of the starting tile and not any point inside of it.
      - Why write a shadow casting implementation from scratch?
        - Saw many claims about shadow casting that made downside claims about it that were actually due to implementation quirks.
          - <http://roguebasin.com/index.php/Shadow_casting#Disadvantages>
            - "Some artifacts (corners of rooms)": RuggRogue's implementation handles room corners without no special casing.
            - "Non-symmetric":
              - *Back-and-forth* symmetry is preserved for open tiles in RuggRogue.
              - *Line-of-sight* symmetry is preserved by ensuring LOS algorithm shares the same view of the world as FOV algorithm; RuggRogue doesn't use LOS.
          - <http://roguebasin.com/index.php/Comparative_study_of_field_of_view_algorithms_for_2D_grid_based_worlds>
            - "Pillar behavior" and "Diagonal walls" are due to wall shape, which is an implementation detail and is not inherent to shadow casting.
          - <http://www.adammil.net/blog/v125_Roguelike_Vision_Algorithms.html>
            - Also claims shadow casting is asymmetric, even though this is an implementation detail and not inherent to shadow casting.
        - Learning: Algorithms and techniques that people don't practice perpetuate confusion over implementation quirks and genuine properties of shadow casting.
    - RuggRogue's approach
      - Shadow casting with symmetric center-to-center visibility for open tiles and asymmetric center-to-mid-line visibility to diamond-shaped walls.
      - Most similar to [Adam Milazzo's description of diamond walls](http://www.adammil.net/blog/v125_Roguelike_Vision_Algorithms.html#diamondwalls), with no zero-width beams.
      - y increases upwards for words like "low" and "high".
      - We'll use "wall" and "floor" to refer to "vision-blocking tile" and "open tile", but tiles don't literally have to be walls and floors.
      - Create an iterator that gets called repeatedly to return visible tile and symmetry information.
        - Many shadow casting implementations use asymmetric vision exclusively to get expansive walls.
        - Smarter implementations apply symmetric vision for floor tiles as a hard-coded special case.
        - RuggRogue returns symmetry information during iteration to let the caller decide.
          - In practice, it uses symmetric floors and asymmetric walls for vision, just without hard-coding.
      - The algorithm:
        1. Visit the starting center tile.
        2. For each of eight octants surrounding the center tile:
            1. Initialize two lists of *sights* (pair of slopes representing visible area): one with a single sight covering the whole octant, the other empty.
            2. For each column (or row) of tiles from the cardinal to diagonal axes extending out from the center tile:
                1. Designate *current* and *next* lists from the two lists in an even-odd manner based on distance from the center tile.
                    - The list of current sights will be used to iterate over visible tiles in the current column of tiles.
                    - The list of next sights will be filled for the next column of tiles based on walls detected in the current column of tiles.
                2. For each sight in the current list for the column:
                    1. Yield the coordinates of each tile in the sight, along with a symmetry check flag.
                    2. Scan for runs of consecutive walls and floors to build up the list of sights for the next column.
        - Nested iteration in four layers: octants, columns, sights and tiles.
        - Compared to *recursive* shadow casting:
          - Breadth-first instead of depth-first.
          - Maintains sight data explicitly in lists instead of implicitly in stack frames.
          - Should be faster; most real-world recursive algorithms tend to be slower than their non-recursive counterparts.
      - How the map is viewed by the algorithm
        - Place grid origin at the *center* of the starting tile.
          - Ensures symmetry when flipping and transposing the map for octants other than the first.
          - *Diagram of grid centered on an at-sign with some walls.*
        - Diamond-shaped walls are identical to plus-shaped walls, which further reduce to a single mid-line for each wall: vertical for columns, horizontal for rows.
          - *Diagram of centered at-sign with scatter walls with mid-lines highlighted.*
    - `ruggrogue::field_of_view` function:
      - `BoundedMap` and `ViewableField` map traits
      - `FovShape` and distance checking with `FovShape::CirclePlus` and `range * (range + 1)`
    - `FovIter` struct:
      - `map`, `start_pos`, `range`: basic FOV inputs
      - `fov_shape`: shape of the FOV
      - `octant`, `x`, `s`, `y`: octant, column/row, sight index, tile in column/row
      - `bounds`: map bounds
      - `max_dist2`: maximum distance squared, used with `fov_shape` for circular FOVs
      - `sights_even`, `sights_odd`: lists of sights for each column/row
      - `low_y`, `high_y`: the low and high values for `y` in the current sight
      - `low_sight_angle`: tracking of the slope of the lowest floor tile if we're in a run of floor tiles
    - `FovIter::next` function calls `FovIter::advance` repeatedly and filters out-of-bounds tiles.
    - `FovIter::advance` function:
      - Using `Option` for `octant`, `x`, `s`, `y`
        - `None` means the value needs initialization
        - `Some(...)` protects against repeat initializations
      - `out_pos` and `out_symmetric` used to yield tile coordinates and symmetry information
      - Rough code outline that shows where `octant`, `x`, `s` and `y` change when `FovIter::advance` is called repeatedly.
      - `FovIter::low_y` and `FovIter::high_y`:
        - The range of values `y` should iterate over.
        - Calculate where the sight slopes intersect the current column.
          - Must add half a tile before rounding down since grid origin is the center of starting tile, not its bottom-left corner.
            - *Diagrams of intersect values with and without grid offset correction.*
          - Example of intersecting values for a non-full octant sight:
            - *Diagram of a sight and the intersection values for a column.*
      - Using `octant_data`:
        - Flip and transpose view of the map with `real_x_from_x`, `real_x_from_y`, `real_y_from_x` and `real_y_from_y`.
        - Real map coords only used to check if in bounds and if current tile is a wall.
        - Only visit shared octant edges if `include_edges` is `true`.
      - Scanning for walls and floors with `FovIter::low_sight_angle`:
        - `None` value means we're not looking at a floor.
        - Gets set to `Some(...)` where the value is the slope of the first floor in a consecutive run of floor tiles.
        - Push a new sight into the next sight list if `low_sight_angle` is `Some(...)` and we hit a wall or the end of the current sight.
        - Calculating `low_mid_angle`, the center of the bottom edge of the tile:
          - Double `y` and `x` to avoid the use of floating point variables.
            - Doesn't change relative steepness order of slopes.
          - *Diagram of the slope to the bottom-center of a tile.*
          - Need to use the higher of `low_angle` and `low_mid_angle` to avoid accidentally creating an expanded sight.
            - *Diagram of the first tile of a sight, with an incorrect slope through the center of its bottom edge, and a correct slope following `low_angle` of the current sight.*
          - Using `angle_lt_or_eq` to compare slopes
            - Derive inequality, explaining numerators and denominators.
      - Visiting visible tiles happens at the same time as scanning for walls and floors.
        - Symmetry just uses `angle_lt_or_eq` to check if the slope of the center of the tile lies between the low and high slopes of the current sight.
    - Conclusion
      - Field of view code is some of the earliest Rust code written for the game.
      - Would change some things to simplify the code, e.g. use Rust's iterator adaptors, like filtering.
      - Logic would be much easier to follow if Rust had generators.
      - Pleased with performance.
      - Good results:
        - symmetric vision with floor tiles
        - no room corner artifacts
        - diamond-shaped walls creates nice vision angles around corners and pillars
  - *Pathfinding using A-star*
    - What pathfinding is used for: monster AI.
    - Pathfinding using the A\* algorithm
      - Link to [Red Blob Games article](https://www.redblobgames.com/pathfinding/a-star/introduction.html).
      - Very briefly describe A\* algorithm.
    - Defining map obstructions with the `PathableMap` trait.
      - `is_blocked` function for `Map` struct.
      - `Map::tile_entities`: the entity spatial cache.
    - The `ruggrogue::find_path` function.
      - Describe where it's used.
      - Limiting degenerate pathfinding with exploration bounds using the `bound_pad` parameter.
      - Fallback pathing with the `fallback_closest` parameter.
      - Reversing the raw output of the A\* implementation.
    - The `a_star` function.
      - Implementation of the A\* algorithm.
      - Storing pathfinding results in the `came_from` argument.
      - `frontier` and `cost_so_far` data structures.
      - Define bounds of exploration with padding with `min_x`, `min_y`, `max_x` and `max_y`.
      - `dist100`: our distance heuristic.
        - Euclidean distance estimation to mimic human perception of distance on the map.
        - Underestimating cardinal movement (99 vs. 100) to line monsters up cardinally with the player.
      - Tracking the closest tile to the goal with `closest`, `closest_cost` and `closest_dist`.
      - The rest is just managing `frontier`, `came_from` and `cost_so_far` according to the A\* algorithm.
  - *Randomness*
    - Random numbers needed to generate and populate levels as well as determine melee attack accuracy and damage.
    - No global RNG.
      - Many other roguelikes create a single RNG and use it everywhere.
      - RuggRogue instead creates temporary RNGs seeded with relevant inputs as necessary.
      - Initializing an RNG:
        1. Create a hasher that takes input values in order to produce an RNG seed.
        2. Input a magic number into the hasher (explain what the magic number is for).
        3. Input other values into the hasher (provide an example to illustrate how values are chosen for this purpose).
        4. Generate the final hash value and use it to seed an RNG.
      - This makes RNGs *reproducible*, which helps for debugging and allows for seeded play (explain further).
    - Where RNGs are used:
      - Map generation.
      - Spawning of items and monsters.
      - Melee combat.
    - Avoiding RNG divergence between native vs. web (i.e. the `usize` problem).
  - *Map generation*
    - Map data
      - `Map` struct in `src/map.rs`
      - Explain `depth`, `width`, `height`, `tiles` and `rooms` fields.
      - Single `Map` instance is created as a unique in the `main` function in `src/main.rs`
        - cleared before generating new maps
        - 80-by-50 tile size assigned here sets the size for all maps for the entire game
    - When levels are generated
      - Starting a new game: `new_game_setup` function in `src/modes/title.rs`
      - Player descends: `player_do_descend` function in `src/player.rs`
    - `generate_rooms_and_corridors` function in `src/map.rs`
      - Creates a map with rooms connected with corridors.
      - Fills the whole map with wall tiles.
      - Rooms and corridors are placed randomly; RNG is created as per the Randomness chapter.
      - Room placement
        - Make a rectangle with a random width and height.
        - Pick a random position on the map.
        - If the rectangle doesn't intersect any existing room, draw floor tiles and add it to the map's room list.
        - Random position avoids placing the rectangle flush with the map edges.
        - `Rect::intersect` function checks one extra tile around to avoid placing rooms flush with one another.
        - Repeated 30 times, usually places 12-15 rooms.
      - Joining rooms with corridors
        - Goal: ensure that all rooms can be reached via corridors.
        - Method:
          1. Add first room to a `connected` list and the rest to a `disconnected` list.
          2. While `disconnected` list still has rooms:
            - Pick the `disconnected` room closest to the `connected` rooms.
            - Join the rooms with a corridor.
            - Move the room from the `disconnected` list to the `connected` list.
        - Explain code for finding closest rooms with code sample.
        - Explain code for drawing corridor tiles: `connect_rooms`.
        - Prim's algorithm: rooms = nodes, corridors = edges.
        - Avoid making player backtrack too often: pick 3 more pairs of rooms and connect them to allow for loops.
      - Finishing touches
        - Place a downstairs in the last room in the room list, or coords to place the victory item if player is deep enough.
  - *Map population*
    - Placing the player
      - Player is placed in the first room in the map's room list.
        - Ensures player and downstairs are placed in different rooms.
      - `player::add_coords_to_players` and `map::place_player_in_first_room` functions.
    - Placing monsters
      - `spawn::fill_room_with_spawns`
      - `fill_room_with_spawns`
      - `spawn_random_monster_at`
      - `spawn_monster`
    - Placing items
      - Randomly-spawned items
        - `spawn::fill_room_with_spawns`
        - `fill_room_with_spawns`
        - `spawn_random_item_at`
        - Item-spawning functions:
          - `spawn_weapon`
          - `spawn_armor`
          - `spawn_health_potion`
          - `spawn_magic_missile_scroll`
          - `spawn_fireball_scroll`
          - `spawn_sleep_scroll`
        - `spawn_item` helper function
      - Guaranteed ration (`spawn_guaranteed_ration`)
      - Guaranteed equipment (`spawn_guaranteed_equipment`)
        - Starting equipment (hard-coded)
        - Periodic equipment
          - Periodic weapon RNG seeding
            - Idea: Give every set of four levels the same RNG seed, roll a number from 0 to 2 and spawn weapon in that level of the set.
            - 0-2 vs. 0-3 to guarantee a gap level.
            - Use low bits of game seed to shift the offset.
          - Periodic armor RNG seeding is the same, but shifts with the high bits of the game seed instead.
  - *Auto-run*
    - Idea: rotate world, check tiles, pick direction, unrotate world.
    - Checked tile patterns are hard-coded, but work well in practice.
    - Integrated to act like real player inputs with additional checks to interrupt it, e.g. monster appears or player presses a key.
  - *Turn order and combat*
    - The damage formula.
    - Avoiding zero damage using tanh.
  - *Items*
  - *Hunger and regeneration*
    - Stomach component and the basics of hunger: ticks down over time, fills when eating, regen when above threshold, starving when zero.
    - Sub-HP and turns to regen to max HP.
    - Implication: higher max HP means faster regen.
  - *Experience and difficulty progression*
    - Experience formula
    - The level factor, which determines everything else.
    - The difficulty tracker, which determines the spawn level of monsters and equipment.
  - *New game plus*
    - Increases monster and item spawns in rooms per win.
    - Resetting difficulty, but still spawning more powerful equipment.
    - Safety save before using victory item, and why.
