- **Intro**
  - What is this doc?
  - Who is it for?
  - What does it cover?
- **Dependencies**
  - bitflags
  - bitvec
  - rand, rand\_xoshiro
  - sdl2 (with "image" feature)
  - serde, serde\_json
  - shipyard
  - wyhash
- **Source code layout**
  - It's around 13K SLOC.
  - Most of this won't make sense; see further for context.
  - `assets/` - font and tile images
  - `src/` - game-specific files, quick overview of each file
  - `src/lib/` - game-agnostic files, quick overview of each file
  - `src/modes/` - mode stack implementation and every mode, describe each file starting with mod.rs
- **How stuff works**
  - No engine (unless SDL2 counts) and no roguelike helper libraries.
  - *Overall game flow*
  - *Game loop*
  - *The mode stack*
    - Avoiding the all-encompassing state machine from the Rust roguelike tutorial.
    - ModeResults, or how to handle responses from menus and dialog boxes.
  - *Event Handling*
    - Receiving events
      - `ruggrogue::run` function in `src/lib/run.rs`
      - SDL event pump in the main loop
    - Direct event handling
      - Window resizing
      - Showing and hiding the mouse cursor
      - `Event::RenderTargetsReset` and `Event::RenderDeviceReset`
    - The input buffer
      - `InputBuffer` struct in `src/lib/input_buffer.rs`
      - Queue for events that should be handled during game logic updates
      - Usage:
        1. `InputBuffer::prepare_input` function called by mode update logic to pull one input from the queue.
        2. `InputBuffer::get_input` function called to check prepared input as often as needed.
        3. End of main loop calls `InputBuffer::clear_input` so next `InputBuffer::prepare_input` call can get the next input.
      - `InputBuffer` tracks press and release of modifier keys, which can be checked for with `InputBuffer::get_mods` function.
    - Player input
      - Most of the gameplay takes place in the context of `DungeonMode::update` function in `src/modes/dungeon.rs`.
      - `DungeonMode::update` calls `player::player_input` to handle player inputs.
      - Returns a value to control how `DungeonMode::update` should react:
        - `PlayerInputResult::NoResult` == do nothing
        - `PlayerInputResult::TurnDone` == finish player turn and give monsters their turn
        - most other options == do something to the mode stack, like show a dialog
      - `player::player_input` function lives in `src/player.rs`.
        - Prepares input with `InputBuffer::prepare_input`.
        - Special handling for player afflicted with sleep status and autorunning.
        - Gets input and active modifiers with `InputBuffer::get_input` and `InputBuffer::get_mods`.
        - Converts raw input key code and modifiers into `GameKey` values.
          - Can map multiple keys to a single action for simulataneous cursor, numpad and vi-keys support.
        - `GameKey` determines player action
          - `try_move_player` function for movement and melee combat
          - `wait_player` function for player waiting a single turn
          - most other keys pass a value back to `DungeonMode::update` to show a dialog or menu
    - The `AppQuit` event
      - Generated from SDL's quit event and added to the `InputBuffer` when the player tries to close the game window.
      - Update logic of every mode reacts in one of three ways:
        1. Most modes immediately remove themselves from the mode stack with an `AppQuit` result.
        2. `DungeonMode` pushes an `AppQuitDialogMode` onto the mode stack to show a save-and-exit confirm dialog.
        3. `AppQuitDialogMode` ignores `AppQuit` events while waiting for the player to pick a response.
      - This overall logic backs out of all menus and dialogs and either quits the game outright or asks the player to save and exit.
  - *Rendering and display using TileGrids*
    - Overarching rendering strategy
      - Describe software rendering for tile-based graphics.
      - Describe hardware rendering of tile-based graphics with a texture altassing approach.
      - Describe RuggRogue's choice: hybrid rendering.
        - Reasons:
          - Separates drawing tile grid contents from how it's displayed on screen (easier positioning + zoom).
          - Pure SDL-based drawing lets SDL choose the best graphics API for its environment.
        - Probably not the fastest it could be, but it seems reasonably fast compared to naive per-tile drawing.
    - TileGrids and TileGridLayers
      - Everything shown by RuggRogue is a TileGrid.
      - Main game loop inits and draws TileGridLayers; essentially a scene graph.
      - Mode stack ensures that each mode gets its own fresh TileGridLayer.
      - Modes can create as many TileGrids as they need within their TileGridLayer.
    - Tilesets: black-and-white conversion, tall vertical surface for cache-friendliness during rendering.
    - The phases of drawing: draw, render, upload, display.
      - Draw: The TileGrid drawing API, implementations mostly passed off to RawTileGrid.
      - Render: Check for changed tiles with RawTileGrids, draw changed tiles.
      - Upload: Single SDL call to do this.
      - Display: Each TileGrid copies itself to the canvas, while main game loop uses SDL to present it all.
    - Improving render performance with wrapped offset rendering.
    - Improving map draw performance with chunked drawing.
  - *User interface*
    - Mode breakdown with YesNoDialogMode as an example.
    - Layout and drawing of the main game screen.
    - The AppQuit event.
  - *Word wrapping*
  - *Entity Component System*
    - How Shipyard is used.
    - RuggRogue uses Shipyard 0.4:
      - Couldn't use Shipyard 0.5 since a transitive dependency broke the web build.
      - 0.4 API differs from 0.5, so it needs to be covered, since 0.4 docs are no longer online.
    - The World
      - Worlds hold uniques and entities with attached components.
      - Creating a world: `World::new`
    - Uniques
      - What is a unique?
      - Adding a unique to the world: `World::add_unique`
      - Accessing uniques: `UniqueView` and `UniqueViewMut`, with examples using `World::borrow`
      - Shipyard 0.4 has no way to delete or replace uniques.
    - Entities and Components
      - What are entities and components?
      - Creating entities: `EntitiesViewMut` and `EntitiesViewMut::add_entity`
      - Removing entities: `AllStoragesViewMut` and `AllStoragesViewMut::delete`
      - Adding components to entities: `EntitiesView` and `EntitiesView::add_component`
      - Deleting components from entities: `ViewMut::delete`
      - Accessing components of a single entity: `View` and `ViewMut` with the `Shipyard::Get` trait
      - Iterating entities that share components: `Shipyard::IntoIter::iter` and `Shipyard::Shiperator::with_id`
      - Using `EntityId` as a handle to an entity
      - Checking if an entity has a component: `View::contains` and `View::try_get`
    - Avoiding systems
      - `World::run` sometimes appears instead of `World::borrow`
      - RuggRogue prefers `World::borrow` for fine-grained control over references.
        - Rust: One mutable reference or multiple immutable references only.
          - Why it helps: data consistency, use screen tearing as an analogy.
      - Shipyard grants references and checks rules at runtime.
        - Lifetimes of most game data depends on player actions, so many of these checks must be at runtime.
          - Leaf functions still use Rust's compile-time checking.
      - Problem: can't `World::run` within `World::run`.
      - Problem: calling a system within a system, using simplified player spawning as an example.
      - Problem: views claimed too early, causing helper functions to panic.
      - All of these problems are from calling functions within functions.
        - Personal style.
        - Using Shipyard's *workloads* runs systems without nesting, embracing the full ECS style.
          - Couldn't use workloads because runs multi-threaded only, which doesn't work in the web build.
  - *Game data* (Entity life cycle)
    - The world, and which entities exist and when.
    - Despawning entities, including entities they refer to.
  - *Save and load*
    - Overview of saving and loading in the context of the rest of the game.
    - The save file format, with a simple example.
    - Handling of EntityIds during saving and loading.
    - Run-length encoding, used to compress map tile data and field of view bits.
    - Save support for the web version.
  - *Field of view*
    - Introduction to vision:
      - Player only sees their immediate surroundings and can't see through walls.
      - As player moves, game maintains memory of previously seen tiles.
      - This is field of view.
      - Main purpose: Create a sense of exploring the unknown.
    - Applications of field of view:
      - Vision for the player and monsters with the `FieldOfView` component.
      - Determining valid target tiles when using an item at range.
      - Calculating affected tiles from the epicenter of an item used with an `AreaOfEffect` component.
    - Shadow Casting
      - Definition: Starting from a center tile, visit only visible tiles while skipping tiles in shadows created by obstructing tiles closer to the center tile.
      - Faster than ray casting (briefly define ray casting).
      - Distinct from permissive field of view (link RogueBasin) in that shadow casting considers visibility only from the center of the starting tile and not any point inside of it.
      - Why write a shadow casting implementation from scratch?
        - Saw many claims about shadow casting that made downside claims about it that were actually due to implementation quirks.
          - <http://roguebasin.com/index.php/Shadow_casting#Disadvantages>
            - "Some artifacts (corners of rooms)": RuggRogue's implementation handles room corners without no special casing.
            - "Non-symmetric":
              - *Back-and-forth* symmetry is preserved for open tiles in RuggRogue.
              - *Line-of-sight* symmetry is preserved by ensuring LOS algorithm shares the same view of the world as FOV algorithm; RuggRogue doesn't use LOS.
          - <http://roguebasin.com/index.php/Comparative_study_of_field_of_view_algorithms_for_2D_grid_based_worlds>
            - "Pillar behavior" and "Diagonal walls" are due to wall shape, which is an implementation detail and is not inherent to shadow casting.
          - <http://www.adammil.net/blog/v125_Roguelike_Vision_Algorithms.html>
            - Also claims shadow casting is asymmetric, even though this is an implementation detail and not inherent to shadow casting.
        - Learning: Algorithms and techniques that people don't practice perpetuate confusion over implementation quirks and genuine properties of shadow casting.
    - RuggRogue's approach
      - Shadow casting with symmetric center-to-center visibility for open tiles and asymmetric center-to-mid-line visibility to diamond-shaped walls.
      - Most similar to [Adam Milazzo's description of diamond walls](http://www.adammil.net/blog/v125_Roguelike_Vision_Algorithms.html#diamondwalls), with no zero-width beams.
      - y increases upwards for words like "low" and "high".
      - We'll use "wall" and "floor" to refer to "vision-blocking tile" and "open tile", but tiles don't literally have to be walls and floors.
      - Create an iterator that gets called repeatedly to return visible tile and symmetry information.
        - Many shadow casting implementations use asymmetric vision exclusively to get expansive walls.
        - Smarter implementations apply symmetric vision for floor tiles as a hard-coded special case.
        - RuggRogue returns symmetry information during iteration to let the caller decide.
          - In practice, it uses symmetric floors and asymmetric walls for vision, just without hard-coding.
      - The algorithm:
        1. Visit the starting center tile.
        2. For each of eight octants surrounding the center tile:
            1. Initialize two lists of *sights* (pair of slopes representing visible area): one with a single sight covering the whole octant, the other empty.
            2. For each column (or row) of tiles from the cardinal to diagonal axes extending out from the center tile:
                1. Designate *current* and *next* lists from the two lists in an even-odd manner based on distance from the center tile.
                    - The list of current sights will be used to iterate over visible tiles in the current column of tiles.
                    - The list of next sights will be filled for the next column of tiles based on walls detected in the current column of tiles.
                2. For each sight in the current list for the column:
                    1. Yield the coordinates of each tile in the sight, along with a symmetry check flag.
                    2. Scan for runs of consecutive walls and floors to build up the list of sights for the next column.
        - Nested iteration in four layers: octants, columns, sights and tiles.
        - Compared to *recursive* shadow casting:
          - Breadth-first instead of depth-first.
          - Maintains sight data explicitly in lists instead of implicitly in stack frames.
          - Should be faster; most real-world recursive algorithms tend to be slower than their non-recursive counterparts.
      - How the map is viewed by the algorithm
        - Place grid origin at the *center* of the starting tile.
          - Ensures symmetry when flipping and transposing the map for octants other than the first.
          - *Diagram of grid centered on an at-sign with some walls.*
        - Diamond-shaped walls are identical to plus-shaped walls, which further reduce to a single mid-line for each wall: vertical for columns, horizontal for rows.
          - *Diagram of centered at-sign with scatter walls with mid-lines highlighted.*
    - `ruggrogue::field_of_view` function:
      - `BoundedMap` and `ViewableField` map traits
      - `FovShape` and distance checking with `FovShape::CirclePlus` and `range * (range + 1)`
    - `FovIter` struct:
      - `map`, `start_pos`, `range`: basic FOV inputs
      - `fov_shape`: shape of the FOV
      - `octant`, `x`, `s`, `y`: octant, column/row, sight index, tile in column/row
      - `bounds`: map bounds
      - `max_dist2`: maximum distance squared, used with `fov_shape` for circular FOVs
      - `sights_even`, `sights_odd`: lists of sights for each column/row
      - `low_y`, `high_y`: the low and high values for `y` in the current sight
      - `low_sight_angle`: tracking of the slope of the lowest floor tile if we're in a run of floor tiles
    - `FovIter::next` function calls `FovIter::advance` repeatedly and filters out-of-bounds tiles.
    - `FovIter::advance` function:
      - Using `Option` for `octant`, `x`, `s`, `y`
        - `None` means the value needs initialization
        - `Some(...)` protects against repeat initializations
      - `out_pos` and `out_symmetric` used to yield tile coordinates and symmetry information
      - Rough code outline that shows where `octant`, `x`, `s` and `y` change when `FovIter::advance` is called repeatedly.
      - `FovIter::low_y` and `FovIter::high_y`:
        - The range of values `y` should iterate over.
        - Calculate where the sight slopes intersect the current column.
          - Must add half a tile before rounding down since grid origin is the center of starting tile, not its bottom-left corner.
            - *Diagrams of intersect values with and without grid offset correction.*
          - Example of intersecting values for a non-full octant sight:
            - *Diagram of a sight and the intersection values for a column.*
      - Using `octant_data`:
        - Flip and transpose view of the map with `real_x_from_x`, `real_x_from_y`, `real_y_from_x` and `real_y_from_y`.
        - Real map coords only used to check if in bounds and if current tile is a wall.
        - Only visit shared octant edges if `include_edges` is `true`.
      - Scanning for walls and floors with `FovIter::low_sight_angle`:
        - `None` value means we're not looking at a floor.
        - Gets set to `Some(...)` where the value is the slope of the first floor in a consecutive run of floor tiles.
        - Push a new sight into the next sight list if `low_sight_angle` is `Some(...)` and we hit a wall or the end of the current sight.
        - Calculating `low_mid_angle`, the center of the bottom edge of the tile:
          - Double `y` and `x` to avoid the use of floating point variables.
            - Doesn't change relative steepness order of slopes.
          - *Diagram of the slope to the bottom-center of a tile.*
          - Need to use the higher of `low_angle` and `low_mid_angle` to avoid accidentally creating an expanded sight.
            - *Diagram of the first tile of a sight, with an incorrect slope through the center of its bottom edge, and a correct slope following `low_angle` of the current sight.*
          - Using `angle_lt_or_eq` to compare slopes
            - Derive inequality, explaining numerators and denominators.
      - Visiting visible tiles happens at the same time as scanning for walls and floors.
        - Symmetry just uses `angle_lt_or_eq` to check if the slope of the center of the tile lies between the low and high slopes of the current sight.
    - Conclusion
      - Field of view code is some of the earliest Rust code written for the game.
      - Would change some things to simplify the code, e.g. use Rust's iterator adaptors, like filtering.
      - Logic would be much easier to follow if Rust had generators.
      - Pleased with performance.
      - Good results:
        - symmetric vision with floor tiles
        - no room corner artifacts
        - diamond-shaped walls creates nice vision angles around corners and pillars
  - *Pathfinding using A-star*
    - What pathfinding is used for: monster AI.
    - Pathfinding using the A\* algorithm
      - Link to [Red Blob Games article](https://www.redblobgames.com/pathfinding/a-star/introduction.html).
      - Very briefly describe A\* algorithm.
    - Defining map obstructions with the `PathableMap` trait.
      - `is_blocked` function for `Map` struct.
      - `Map::tile_entities`: the entity spatial cache.
    - The `ruggrogue::find_path` function.
      - Describe where it's used.
      - Limiting degenerate pathfinding with exploration bounds using the `bound_pad` parameter.
      - Fallback pathing with the `fallback_closest` parameter.
      - Reversing the raw output of the A\* implementation.
    - The `a_star` function.
      - Implementation of the A\* algorithm.
      - Storing pathfinding results in the `came_from` argument.
      - `frontier` and `cost_so_far` data structures.
      - Define bounds of exploration with padding with `min_x`, `min_y`, `max_x` and `max_y`.
      - `dist100`: our distance heuristic.
        - Euclidean distance estimation to mimic human perception of distance on the map.
        - Underestimating cardinal movement (99 vs. 100) to line monsters up cardinally with the player.
      - Tracking the closest tile to the goal with `closest`, `closest_cost` and `closest_dist`.
      - The rest is just managing `frontier`, `came_from` and `cost_so_far` according to the A\* algorithm.
  - *Randomness*
    - Random numbers needed to generate and populate levels as well as determine melee attack accuracy and damage.
    - No global RNG.
      - Many other roguelikes create a single RNG and use it everywhere.
      - RuggRogue instead creates temporary RNGs seeded with relevant inputs as necessary.
      - Initializing an RNG:
        1. Create a hasher that takes input values in order to produce an RNG seed.
        2. Input a magic number into the hasher (explain what the magic number is for).
        3. Input other values into the hasher (provide an example to illustrate how values are chosen for this purpose).
        4. Generate the final hash value and use it to seed an RNG.
      - This makes RNGs *reproducible*, which helps for debugging and allows for seeded play (explain further).
    - Where RNGs are used:
      - Map generation.
      - Spawning of items and monsters.
      - Melee combat.
    - Avoiding RNG divergence between native vs. web (i.e. the `usize` problem).
  - *Map generation*
    - Map data
      - `Map` struct in `src/map.rs`
      - Explain `depth`, `width`, `height`, `tiles` and `rooms` fields.
      - Single `Map` instance is created as a unique in the `main` function in `src/main.rs`
        - cleared before generating new maps
        - 80-by-50 tile size assigned here sets the size for all maps for the entire game
    - When levels are generated
      - Starting a new game: `new_game_setup` function in `src/modes/title.rs`
      - Player descends: `player_do_descend` function in `src/player.rs`
    - `generate_rooms_and_corridors` function in `src/map.rs`
      - Creates a map with rooms connected with corridors.
      - Fills the whole map with wall tiles.
      - Rooms and corridors are placed randomly; RNG is created as per the Randomness chapter.
      - Room placement
        - Make a rectangle with a random width and height.
        - Pick a random position on the map.
        - If the rectangle doesn't intersect any existing room, draw floor tiles and add it to the map's room list.
        - Random position avoids placing the rectangle flush with the map edges.
        - `Rect::intersect` function checks one extra tile around to avoid placing rooms flush with one another.
        - Repeated 30 times, usually places 12-15 rooms.
      - Joining rooms with corridors
        - Goal: ensure that all rooms can be reached via corridors.
        - Method:
          1. Add first room to a `connected` list and the rest to a `disconnected` list.
          2. While `disconnected` list still has rooms:
            - Pick the `disconnected` room closest to the `connected` rooms.
            - Join the rooms with a corridor.
            - Move the room from the `disconnected` list to the `connected` list.
        - Explain code for finding closest rooms with code sample.
        - Explain code for drawing corridor tiles: `connect_rooms`.
        - Prim's algorithm: rooms = nodes, corridors = edges.
        - Avoid making player backtrack too often: pick 3 more pairs of rooms and connect them to allow for loops.
      - Finishing touches
        - Place a downstairs in the last room in the room list, or coords to place the victory item if player is deep enough.
  - *Map population*
    - Placing the player
      - Player is placed in the first room in the map's room list.
        - Ensures player and downstairs are placed in different rooms.
      - `player::add_coords_to_players` and `map::place_player_in_first_room` functions.
    - Placing monsters
      - `spawn::fill_room_with_spawns`
      - `fill_room_with_spawns`
      - `spawn_random_monster_at`
      - `spawn_monster`
    - Placing items
      - Randomly-spawned items
        - `spawn::fill_room_with_spawns`
        - `fill_room_with_spawns`
        - `spawn_random_item_at`
        - Item-spawning functions:
          - `spawn_weapon`
          - `spawn_armor`
          - `spawn_health_potion`
          - `spawn_magic_missile_scroll`
          - `spawn_fireball_scroll`
          - `spawn_sleep_scroll`
        - `spawn_item` helper function
      - Guaranteed ration (`spawn_guaranteed_ration`)
      - Guaranteed equipment (`spawn_guaranteed_equipment`)
        - Starting equipment (hard-coded)
        - Periodic equipment
          - Periodic weapon RNG seeding
            - Idea: Give every set of four levels the same RNG seed, roll a number from 0 to 2 and spawn weapon in that level of the set.
            - 0-2 vs. 0-3 to guarantee a gap level.
            - Use low bits of game seed to shift the offset.
          - Periodic armor RNG seeding is the same, but shifts with the high bits of the game seed instead.
  - *Auto-run*
    - Most of the time playing RuggRogue is spent moving from place to place.
    - Instead of repeatedly pressing movement keys, the player can tell the game to move in a direction until something interesting is seen.
    - This feature is known as *auto-running*.
    - Auto-Run Basics
      - Integrated to act like real player inputs with additional checks to interrupt it, e.g. monster appears or player presses a key.
      - Hold shift and press movement key to auto-run in that direction.
      - Three kinds of auto-run:
        1. *Rest in place*: Shift+Space to rest until fully healed.
        2. *Straight auto-run*: Shift+direction in open space or against a wall on one side to move in one direction until terrain changes.
        3. *Corridor auto-run*: Shift+direction in a corridor to follow the corridor until it branches or opens up.
      - Once auto-run starts it issues movement commands until interrupted by:
        - the player presses a key
        - a monster appears in the player's field of view
        - the player moves next to an item or downstairs tile
    - Auto-Run Data Structures
      - `auto_run` field in `Player` struct in `src/components.rs`
      - `AutoRun` struct in `src/player.rs`
      - `AutoRunType` enum in `src/player.rs`
      - `AutoRunWallSide` enum in `src/player.rs`
    - Automatic Inputs
      - If Shift is held when a movement key is pressed, the turn is mostly handled as usual, but `auto_run` in `Player` is set to begin auto-running process.
      - `player_input` fn in `src/player.rs`
        - checks for interruption from key press, adjacent items or stairs or enemies in sight
        - decrements `auto_run.limit` and stops auto-running when it reaches zero
        - calls `auto_run_next_step` fn for next direction to move
        - with a step, calls `try_move_player` or `wait_player` fns like normal player input
        - without a step, stops auto-running
      - bottom of `DungeonMode::update` fn returns `ModeUpdate::Update` if auto-run is active
        - breaks away from game's usual post-update behavior of waiting for an event before updating
        - (include code skeleton here)
    - Resting in Place
      - Detect auto-run input
        - Normal input logic in `player::player_input` fn checks for Shift key, passes it on to `wait_player` fn as `rest_in_place` arg
      - Check that resting in place can start, if not, exit early with message why
      - Start resting in place by setting `auto_run` field of `Player` struct with `run_type` of `AutoRunType::RestInPlace`
      - On next frame, `player::player_input` fn runs auto-run logic instead of normal input logic
      - Check if auto-run should stop for:
        - `AppQuit` event
        - key press
        - any monster in field of view (`player_sees_foes` fn)
        - auto-run turn limit (decremented and checked)
      - Check main auto-run condition with `auto_run_next_step` fn
        - returns `Some(...)` to continue or `None` to stop auto-run
      - If auto-run should stop, call `player_stop_auto_run` fn to unset `auto_run` field of `Player` struct
      - Otherwise, perform one step of auto-run with `wait_player` fn
    - Straight Auto-Run
      - Straight auto-run is triggered with Shift+dir in open space on both sides of their direction of movement, or open space on one side and a closed wall on the other side.
        - Closed walls on both sides should be handled with corridor auto-run logic instead.
        - Straight auto-run stops when the state of walls around the player changes, or the player steps next to items or the downstairs tile.
      - Wall and space checking is handled by `auto_run_straight_check` fn, adjacent tile check is handled by `player_check_frontier` fn, both in `src/player.rs` file.
        - Tiles checked by these functions differs based on the direction the player is moving.
        - The player can move in eight directions, but we don't want to repeat similar code for every direction.
        - Instead, RuggRogue checks tiles for the player moving straight right and diagonally up-right, then *rotates* these logical tiles to match the player's movement direction.
      - Rotating by Movement Direction
        - Rotation in the `auto_run_straight_check` fn starts by reading the player's movement direction into the `run_dx` and `run_dy` variables.
        - `run_dx` and `run_dy` are fed into the `rotate_view` fn to retrieve rotation parameters: `real_x_from_x`, `real_x_from_y`, `real_y_from_x`, `real_y_from_y`.
        - Aside: Consider increases to `y` as up by convention.
        - To rotate, we need to think about how the real map `x` and `y` change when `run_dx` and `run_dy` change.
        - e.g. Rotating logical coordinates 90 degrees anti-clockwise
          - when `run_dx` increases (+1), real map `x` remains stationary (`real_x_from_x` == 0) while real map `y` increases (`real_y_from_x` == 1)
          - when `run_dy` increases (+1), real map `x` decreases (`real_x_from_y` == -1) while real map `y` remains stationary (`real_y_from_y` == 0)
        - (post full table of parameters from `rotate_view` fn here)
        - (post and describe `real_x` and `real_y` helper closures from `auto_run_straight_check` fn here)
      - Checking for Walls and Open Space
        - To decide if straight auto-run should start or continue, the tiles around the player need to be looked at.
        - `auto_run_straight_check` fn does this and returns:
          - `Some(AutoRunWallSide::Left)` == complete wall on left and completely open tiles on right
          - `Some(AutoRunWallSide::Right)` == complete wall on right and completely open tiles on left
          - `Some(AutoRunWallSide::Neither)` == completely open tiles on left and right
          - `None` == anything else, including wall in front
        - (post tiles checked for player moving right; relate `real_x`, `real_y` and possible return values)
        - (post tiles checked for player moving up-right)
      - Checking for Items and Downstairs
        - Auto-run can also stop for items and downstairs; checked with `player_check_frontier` fn.
        - Checks current player position as well as newly-adjacent tiles in the player's movement direction.
        - (post tiles checked for player moving right)
        - (post tiles checked for player moving up-right)
      - Putting It All Together
        - Like resting in place, normal input logic in `player::player_input` fn checks for Shift, but sends result to `try_move_player` fn as `start_run` arg
        - In `try_move_player` fn, run attempt is stopped if any monsters are in the player's field of view.
        - If movement occurred, game decides if corridor auto-run or straight auto-run should begin.
        - If `auto_run_straight_check` fn succeeds, store the `AutoRunType` value returned in the `run_type` field of player's `AutoRun` struct
        - On subsequent frames, continue straight auto-run in the `player::player_input` fn until:
          1. `player_check_frontier` fn finds something next to the player
          2. `auto_run_straight_check` fn (called via `auto_run_next_step` fn) returns a different `AutoRunType` value at the player's current position to the one stored in the `run_type` field
    - Corridor Auto-Run
      - Corridor auto-run follows single-tile-wide corridors until they fork, open up or end.
      - Corridor auto-run is nearly identical to straight auto-run with three key differences:
        1. The check to start or continue auto-running is performed by the `auto_run_corridor_check` fn instead of the `auto_run_straight_check` fn.
        2. The `auto_run_corridor_check` fn returns the direction of the next step along the corridor instead of the state of surrounding walls and open spaces.
        3. The auto-run direction is constantly *updated* to follow the corridor.
      - The `auto_run_corridor_check` fn takes the player's movement direction, checks surrounding tiles and returns `Some((dx, dy))`, the dir of the next step
      - The player's corridor auto-run direction is updated at each step in the `auto_run_next_step` fn.
      - The `auto_run_corridor_check` fn rotates the tiles it checks to the player's movement direction with the help of the `rotate_view` fn, much like the `auto_run_straight_check` fn.
        - Also used to rotate the returned direction of the next corridor auto-run step.
      - Tiles around the player are checked for walls.
        - The tiles chosen depend on the player's movement direction.
        - Each wall sets an individual bit in a 16-bit unsigned integer variable named `nearby_walls`.
      - The bits of the `nearby_walls` variable are matched against patterns of wall and non-wall tiles stored in tables.
        - A successful match returns the next direction for corridor auto-run to follow, adjusted for rotation.
        - There are separate tables for the player moving right and up-right; rotation collapses all other directions into just those two.
      - (Provide simplified 8-bit example of pattern matching using first case after cardinal player move.)
      - (List basic cardinal patterns here.)
        - Wants one open tile with a 90-degree change in direction at most.
        - That one open tile must have walls on both sides.
      - (List cardinal corner patterns here.)
        - Corridor corners put two open tiles next to the player instead of one.
        - Needs to check some tiles two steps away from the player; treat unseen tiles like walls for testing purposes.
        - Player can step into either open tile; game chooses to step into the corner instead of cutting the corner.
      - (List basic diagonal patterns here.)
      - (List diagonal corner patterns here.)
    - Interrupting Auto-Run for Hunger
      - The game has a hunger mechanic where the player gets hungry over time and must eat to ward it off.
      - Hunger level is shown in the side bar, e.g. "Full", "Normal", "Hungry", "Very Hungry", "Famished" or "Starving".
        - Auto-run stops when hunger drops from one level to another below "Normal", e.g. "Normal" to "Hungry" or "Hungry" to "Very Hungry".
      - When player's hunger level is "Starving" they'll periodically lose hit points, which also stops auto-run.
      - All of this happens in the `hunger::tick_hunger` fn in the `src/hunger.rs` file.
  - *Turn order and combat*
    - The damage formula.
    - Avoiding zero damage using tanh.
  - *Items*
  - *Hunger and regeneration*
    - Stomach component and the basics of hunger: ticks down over time, fills when eating, regen when above threshold, starving when zero.
    - Sub-HP and turns to regen to max HP.
    - Implication: higher max HP means faster regen.
  - *Experience and difficulty progression*
    - Experience formula
    - The level factor, which determines everything else.
    - The difficulty tracker, which determines the spawn level of monsters and equipment.
  - *New game plus*
    - Increases monster and item spawns in rooms per win.
    - Resetting difficulty, but still spawning more powerful equipment.
    - Safety save before using victory item, and why.
