- **Intro**
  - Describe the game
    - Link the game
    - Describe the source and tech
  - Describe the book
    - Case study of a roguelike built without a game engine or any roguelike helper libraries
    - Focus: describe how ideas translate into source code, files, functions and variables
  - Who is the book for?
    - Roguelike developers
      - Aspiring: Learn how a roguelike works in practice.
      - Current: Compare and contrast implementation approaches with their own games.
    - Programmers curious about one way to make a game without a game engine.
  - How to read the book
    - Chapters are mostly standalone
      - Chapter cross-references usually point backwards
      - Chapters vary in balance between ideas vs. details
    - In general, many references to names of files, functions and variables
      - Gain the most from reading with source code open in another window
      - If not, text can still be skimmed for ideas
  - Chapter overview
- **Dependencies**
  - bitflags
  - bitvec
  - rand, rand\_xoshiro
  - sdl2 (with "image" feature)
  - serde, serde\_json
  - shipyard
  - wyhash
- **Source code layout**
  - It's around 13K SLOC.
  - Most of this won't make sense; see further for context.
  - `assets/` - font and tile images
  - `src/` - game-specific files, quick overview of each file
  - `src/lib/` - game-agnostic files, quick overview of each file
  - `src/modes/` - mode stack implementation and every mode, describe each file starting with mod.rs
- **How stuff works**
  - No engine (unless SDL2 counts) and no roguelike helper libraries.
  - *Overall game flow*
  - *Game loop*
  - *The mode stack*
    - Avoiding the all-encompassing state machine from the Rust roguelike tutorial.
    - ModeResults, or how to handle responses from menus and dialog boxes.
  - *Event Handling*
    - Receiving events
      - `ruggrogue::run` function in `src/lib/run.rs`
      - SDL event pump in the main loop
    - Direct event handling
      - Window resizing
      - Showing and hiding the mouse cursor
      - `Event::RenderTargetsReset` and `Event::RenderDeviceReset`
    - The input buffer
      - `InputBuffer` struct in `src/lib/input_buffer.rs`
      - Queue for events that should be handled during game logic updates
      - Usage:
        1. `InputBuffer::prepare_input` function called by mode update logic to pull one input from the queue.
        2. `InputBuffer::get_input` function called to check prepared input as often as needed.
        3. End of main loop calls `InputBuffer::clear_input` so next `InputBuffer::prepare_input` call can get the next input.
      - `InputBuffer` tracks press and release of modifier keys, which can be checked for with `InputBuffer::get_mods` function.
    - Player input
      - Most of the gameplay takes place in the context of `DungeonMode::update` function in `src/modes/dungeon.rs`.
      - `DungeonMode::update` calls `player::player_input` to handle player inputs.
      - Returns a value to control how `DungeonMode::update` should react:
        - `PlayerInputResult::NoResult` == do nothing
        - `PlayerInputResult::TurnDone` == finish player turn and give monsters their turn
        - most other options == do something to the mode stack, like show a dialog
      - `player::player_input` function lives in `src/player.rs`.
        - Prepares input with `InputBuffer::prepare_input`.
        - Special handling for player afflicted with sleep status and autorunning.
        - Gets input and active modifiers with `InputBuffer::get_input` and `InputBuffer::get_mods`.
        - Converts raw input key code and modifiers into `GameKey` values.
          - Can map multiple keys to a single action for simulataneous cursor, numpad and vi-keys support.
        - `GameKey` determines player action
          - `try_move_player` function for movement and melee combat
          - `wait_player` function for player waiting a single turn
          - most other keys pass a value back to `DungeonMode::update` to show a dialog or menu
    - The `AppQuit` event
      - Generated from SDL's quit event and added to the `InputBuffer` when the player tries to close the game window.
      - Update logic of every mode reacts in one of three ways:
        1. Most modes immediately remove themselves from the mode stack with an `AppQuit` result.
        2. `DungeonMode` pushes an `AppQuitDialogMode` onto the mode stack to show a save-and-exit confirm dialog.
        3. `AppQuitDialogMode` ignores `AppQuit` events while waiting for the player to pick a response.
      - This overall logic backs out of all menus and dialogs and either quits the game outright or asks the player to save and exit.
  - *Rendering and display using TileGrids*
    - Overarching rendering strategy
      - Describe software rendering for tile-based graphics.
      - Describe hardware rendering of tile-based graphics with a texture altassing approach.
      - Describe RuggRogue's choice: hybrid rendering.
        - Reasons:
          - Separates drawing tile grid contents from how it's displayed on screen (easier positioning + zoom).
          - Pure SDL-based drawing lets SDL choose the best graphics API for its environment.
        - Probably not the fastest it could be, but it seems reasonably fast compared to naive per-tile drawing.
    - TileGrids and TileGridLayers
      - Everything shown by RuggRogue is a TileGrid.
      - Main game loop inits and draws TileGridLayers; essentially a scene graph.
      - Mode stack ensures that each mode gets its own fresh TileGridLayer.
      - Modes can create as many TileGrids as they need within their TileGridLayer.
    - Tilesets: black-and-white conversion, tall vertical surface for cache-friendliness during rendering.
    - The phases of drawing: draw, render, upload, display.
      - Draw: The TileGrid drawing API, implementations mostly passed off to RawTileGrid.
      - Render: Check for changed tiles with RawTileGrids, draw changed tiles.
      - Upload: Single SDL call to do this.
      - Display: Each TileGrid copies itself to the canvas, while main game loop uses SDL to present it all.
    - Improving render performance with wrapped offset rendering.
    - Improving map draw performance with chunked drawing.
  - *User interface*
    - Mode breakdown with YesNoDialogMode as an example.
    - Layout and drawing of the main game screen.
    - The AppQuit event.
  - *Word wrapping*
  - *Entity Component System*
    - How Shipyard is used.
    - RuggRogue uses Shipyard 0.4:
      - Couldn't use Shipyard 0.5 since a transitive dependency broke the web build.
      - 0.4 API differs from 0.5, so it needs to be covered, since 0.4 docs are no longer online.
    - The World
      - Worlds hold uniques and entities with attached components.
      - Creating a world: `World::new`
    - Uniques
      - What is a unique?
      - Adding a unique to the world: `World::add_unique`
      - Accessing uniques: `UniqueView` and `UniqueViewMut`, with examples using `World::borrow`
      - Shipyard 0.4 has no way to delete or replace uniques.
    - Entities and Components
      - What are entities and components?
      - Creating entities: `EntitiesViewMut` and `EntitiesViewMut::add_entity`
      - Removing entities: `AllStoragesViewMut` and `AllStoragesViewMut::delete`
      - Adding components to entities: `EntitiesView` and `EntitiesView::add_component`
      - Deleting components from entities: `ViewMut::delete`
      - Accessing components of a single entity: `View` and `ViewMut` with the `Shipyard::Get` trait
      - Iterating entities that share components: `Shipyard::IntoIter::iter` and `Shipyard::Shiperator::with_id`
      - Using `EntityId` as a handle to an entity
      - Checking if an entity has a component: `View::contains` and `View::try_get`
    - Avoiding systems
      - `World::run` sometimes appears instead of `World::borrow`
      - RuggRogue prefers `World::borrow` for fine-grained control over references.
        - Rust: One mutable reference or multiple immutable references only.
          - Why it helps: data consistency, use screen tearing as an analogy.
      - Shipyard grants references and checks rules at runtime.
        - Lifetimes of most game data depends on player actions, so many of these checks must be at runtime.
          - Leaf functions still use Rust's compile-time checking.
      - Problem: can't `World::run` within `World::run`.
      - Problem: calling a system within a system, using simplified player spawning as an example.
      - Problem: views claimed too early, causing helper functions to panic.
      - All of these problems are from calling functions within functions.
        - Personal style.
        - Using Shipyard's *workloads* runs systems without nesting, embracing the full ECS style.
          - Couldn't use workloads because runs multi-threaded only, which doesn't work in the web build.
  - *Game data* (Entity life cycle)
    - The world, and which entities exist and when.
    - Despawning entities, including entities they refer to.
  - *Save and load*
    - Overview of saving and loading in the context of the rest of the game.
    - The save file format, with a simple example.
    - Handling of EntityIds during saving and loading.
    - Run-length encoding, used to compress map tile data and field of view bits.
    - Save support for the web version.
  - *Field of view*
    - Introduction to vision:
      - Player only sees their immediate surroundings and can't see through walls.
      - As player moves, game maintains memory of previously seen tiles.
      - This is field of view.
      - Main purpose: Create a sense of exploring the unknown.
    - Applications of field of view:
      - Vision for the player and monsters with the `FieldOfView` component.
      - Determining valid target tiles when using an item at range.
      - Calculating affected tiles from the epicenter of an item used with an `AreaOfEffect` component.
    - Shadow Casting
      - Definition: Starting from a center tile, visit only visible tiles while skipping tiles in shadows created by obstructing tiles closer to the center tile.
      - Faster than ray casting (briefly define ray casting).
      - Distinct from permissive field of view (link RogueBasin) in that shadow casting considers visibility only from the center of the starting tile and not any point inside of it.
      - Why write a shadow casting implementation from scratch?
        - Saw many claims about shadow casting that made downside claims about it that were actually due to implementation quirks.
          - <http://roguebasin.com/index.php/Shadow_casting#Disadvantages>
            - "Some artifacts (corners of rooms)": RuggRogue's implementation handles room corners without no special casing.
            - "Non-symmetric":
              - *Back-and-forth* symmetry is preserved for open tiles in RuggRogue.
              - *Line-of-sight* symmetry is preserved by ensuring LOS algorithm shares the same view of the world as FOV algorithm; RuggRogue doesn't use LOS.
          - <http://roguebasin.com/index.php/Comparative_study_of_field_of_view_algorithms_for_2D_grid_based_worlds>
            - "Pillar behavior" and "Diagonal walls" are due to wall shape, which is an implementation detail and is not inherent to shadow casting.
          - <http://www.adammil.net/blog/v125_Roguelike_Vision_Algorithms.html>
            - Also claims shadow casting is asymmetric, even though this is an implementation detail and not inherent to shadow casting.
        - Learning: Algorithms and techniques that people don't practice perpetuate confusion over implementation quirks and genuine properties of shadow casting.
    - RuggRogue's approach
      - Shadow casting with symmetric center-to-center visibility for open tiles and asymmetric center-to-mid-line visibility to diamond-shaped walls.
      - Most similar to [Adam Milazzo's description of diamond walls](http://www.adammil.net/blog/v125_Roguelike_Vision_Algorithms.html#diamondwalls), with no zero-width beams.
      - y increases upwards for words like "low" and "high".
      - We'll use "wall" and "floor" to refer to "vision-blocking tile" and "open tile", but tiles don't literally have to be walls and floors.
      - Create an iterator that gets called repeatedly to return visible tile and symmetry information.
        - Many shadow casting implementations use asymmetric vision exclusively to get expansive walls.
        - Smarter implementations apply symmetric vision for floor tiles as a hard-coded special case.
        - RuggRogue returns symmetry information during iteration to let the caller decide.
          - In practice, it uses symmetric floors and asymmetric walls for vision, just without hard-coding.
      - The algorithm:
        1. Visit the starting center tile.
        2. For each of eight octants surrounding the center tile:
            1. Initialize two lists of *sights* (pair of slopes representing visible area): one with a single sight covering the whole octant, the other empty.
            2. For each column (or row) of tiles from the cardinal to diagonal axes extending out from the center tile:
                1. Designate *current* and *next* lists from the two lists in an even-odd manner based on distance from the center tile.
                    - The list of current sights will be used to iterate over visible tiles in the current column of tiles.
                    - The list of next sights will be filled for the next column of tiles based on walls detected in the current column of tiles.
                2. For each sight in the current list for the column:
                    1. Yield the coordinates of each tile in the sight, along with a symmetry check flag.
                    2. Scan for runs of consecutive walls and floors to build up the list of sights for the next column.
        - Nested iteration in four layers: octants, columns, sights and tiles.
        - Compared to *recursive* shadow casting:
          - Breadth-first instead of depth-first.
          - Maintains sight data explicitly in lists instead of implicitly in stack frames.
          - Should be faster; most real-world recursive algorithms tend to be slower than their non-recursive counterparts.
      - How the map is viewed by the algorithm
        - Place grid origin at the *center* of the starting tile.
          - Ensures symmetry when flipping and transposing the map for octants other than the first.
          - *Diagram of grid centered on an at-sign with some walls.*
        - Diamond-shaped walls are identical to plus-shaped walls, which further reduce to a single mid-line for each wall: vertical for columns, horizontal for rows.
          - *Diagram of centered at-sign with scatter walls with mid-lines highlighted.*
    - `ruggrogue::field_of_view` function:
      - `BoundedMap` and `ViewableField` map traits
      - `FovShape` and distance checking with `FovShape::CirclePlus` and `range * (range + 1)`
    - `FovIter` struct:
      - `map`, `start_pos`, `range`: basic FOV inputs
      - `fov_shape`: shape of the FOV
      - `octant`, `x`, `s`, `y`: octant, column/row, sight index, tile in column/row
      - `bounds`: map bounds
      - `max_dist2`: maximum distance squared, used with `fov_shape` for circular FOVs
      - `sights_even`, `sights_odd`: lists of sights for each column/row
      - `low_y`, `high_y`: the low and high values for `y` in the current sight
      - `low_sight_angle`: tracking of the slope of the lowest floor tile if we're in a run of floor tiles
    - `FovIter::next` function calls `FovIter::advance` repeatedly and filters out-of-bounds tiles.
    - `FovIter::advance` function:
      - Using `Option` for `octant`, `x`, `s`, `y`
        - `None` means the value needs initialization
        - `Some(...)` protects against repeat initializations
      - `out_pos` and `out_symmetric` used to yield tile coordinates and symmetry information
      - Rough code outline that shows where `octant`, `x`, `s` and `y` change when `FovIter::advance` is called repeatedly.
      - `FovIter::low_y` and `FovIter::high_y`:
        - The range of values `y` should iterate over.
        - Calculate where the sight slopes intersect the current column.
          - Must add half a tile before rounding down since grid origin is the center of starting tile, not its bottom-left corner.
            - *Diagrams of intersect values with and without grid offset correction.*
          - Example of intersecting values for a non-full octant sight:
            - *Diagram of a sight and the intersection values for a column.*
      - Using `octant_data`:
        - Flip and transpose view of the map with `real_x_from_x`, `real_x_from_y`, `real_y_from_x` and `real_y_from_y`.
        - Real map coords only used to check if in bounds and if current tile is a wall.
        - Only visit shared octant edges if `include_edges` is `true`.
      - Scanning for walls and floors with `FovIter::low_sight_angle`:
        - `None` value means we're not looking at a floor.
        - Gets set to `Some(...)` where the value is the slope of the first floor in a consecutive run of floor tiles.
        - Push a new sight into the next sight list if `low_sight_angle` is `Some(...)` and we hit a wall or the end of the current sight.
        - Calculating `low_mid_angle`, the center of the bottom edge of the tile:
          - Double `y` and `x` to avoid the use of floating point variables.
            - Doesn't change relative steepness order of slopes.
          - *Diagram of the slope to the bottom-center of a tile.*
          - Need to use the higher of `low_angle` and `low_mid_angle` to avoid accidentally creating an expanded sight.
            - *Diagram of the first tile of a sight, with an incorrect slope through the center of its bottom edge, and a correct slope following `low_angle` of the current sight.*
          - Using `angle_lt_or_eq` to compare slopes
            - Derive inequality, explaining numerators and denominators.
      - Visiting visible tiles happens at the same time as scanning for walls and floors.
        - Symmetry just uses `angle_lt_or_eq` to check if the slope of the center of the tile lies between the low and high slopes of the current sight.
    - Conclusion
      - Field of view code is some of the earliest Rust code written for the game.
      - Would change some things to simplify the code, e.g. use Rust's iterator adaptors, like filtering.
      - Logic would be much easier to follow if Rust had generators.
      - Pleased with performance.
      - Good results:
        - symmetric vision with floor tiles
        - no room corner artifacts
        - diamond-shaped walls creates nice vision angles around corners and pillars
  - *Pathfinding using A-star*
    - What pathfinding is used for: monster AI.
    - Pathfinding using the A\* algorithm
      - Link to [Red Blob Games article](https://www.redblobgames.com/pathfinding/a-star/introduction.html).
      - Very briefly describe A\* algorithm.
    - Defining map obstructions with the `PathableMap` trait.
      - `is_blocked` function for `Map` struct.
      - `Map::tile_entities`: the entity spatial cache.
    - The `ruggrogue::find_path` function.
      - Describe where it's used.
      - Limiting degenerate pathfinding with exploration bounds using the `bound_pad` parameter.
      - Fallback pathing with the `fallback_closest` parameter.
      - Reversing the raw output of the A\* implementation.
    - The `a_star` function.
      - Implementation of the A\* algorithm.
      - Storing pathfinding results in the `came_from` argument.
      - `frontier` and `cost_so_far` data structures.
      - Define bounds of exploration with padding with `min_x`, `min_y`, `max_x` and `max_y`.
      - `dist100`: our distance heuristic.
        - Euclidean distance estimation to mimic human perception of distance on the map.
        - Underestimating cardinal movement (99 vs. 100) to line monsters up cardinally with the player.
      - Tracking the closest tile to the goal with `closest`, `closest_cost` and `closest_dist`.
      - The rest is just managing `frontier`, `came_from` and `cost_so_far` according to the A\* algorithm.
  - *Randomness*
    - Random numbers needed to generate and populate levels as well as determine melee attack accuracy and damage.
    - No global RNG.
      - Many other roguelikes create a single RNG and use it everywhere.
      - RuggRogue instead creates temporary RNGs seeded with relevant inputs as necessary.
      - Initializing an RNG:
        1. Create a hasher that takes input values in order to produce an RNG seed.
        2. Input a magic number into the hasher (explain what the magic number is for).
        3. Input other values into the hasher (provide an example to illustrate how values are chosen for this purpose).
        4. Generate the final hash value and use it to seed an RNG.
      - This makes RNGs *reproducible*, which helps for debugging and allows for seeded play (explain further).
    - Where RNGs are used:
      - Map generation.
      - Spawning of items and monsters.
      - Melee combat.
    - Avoiding RNG divergence between native vs. web (i.e. the `usize` problem).
  - *Map generation*
    - Map data
      - `Map` struct in `src/map.rs`
      - Explain `depth`, `width`, `height`, `tiles` and `rooms` fields.
      - Single `Map` instance is created as a unique in the `main` function in `src/main.rs`
        - cleared before generating new maps
        - 80-by-50 tile size assigned here sets the size for all maps for the entire game
    - When levels are generated
      - Starting a new game: `new_game_setup` function in `src/modes/title.rs`
      - Player descends: `player_do_descend` function in `src/player.rs`
    - `generate_rooms_and_corridors` function in `src/map.rs`
      - Creates a map with rooms connected with corridors.
      - Fills the whole map with wall tiles.
      - Rooms and corridors are placed randomly; RNG is created as per the Randomness chapter.
      - Room placement
        - Make a rectangle with a random width and height.
        - Pick a random position on the map.
        - If the rectangle doesn't intersect any existing room, draw floor tiles and add it to the map's room list.
        - Random position avoids placing the rectangle flush with the map edges.
        - `Rect::intersect` function checks one extra tile around to avoid placing rooms flush with one another.
        - Repeated 30 times, usually places 12-15 rooms.
      - Joining rooms with corridors
        - Goal: ensure that all rooms can be reached via corridors.
        - Method:
          1. Add first room to a `connected` list and the rest to a `disconnected` list.
          2. While `disconnected` list still has rooms:
            - Pick the `disconnected` room closest to the `connected` rooms.
            - Join the rooms with a corridor.
            - Move the room from the `disconnected` list to the `connected` list.
        - Explain code for finding closest rooms with code sample.
        - Explain code for drawing corridor tiles: `connect_rooms`.
        - Prim's algorithm: rooms = nodes, corridors = edges.
        - Avoid making player backtrack too often: pick 3 more pairs of rooms and connect them to allow for loops.
      - Finishing touches
        - Place a downstairs in the last room in the room list, or coords to place the victory item if player is deep enough.
  - *Map population*
    - Placing the player
      - Player is placed in the first room in the map's room list.
        - Ensures player and downstairs are placed in different rooms.
      - `player::add_coords_to_players` and `map::place_player_in_first_room` functions.
    - Placing monsters
      - `spawn::fill_room_with_spawns`
      - `fill_room_with_spawns`
      - `spawn_random_monster_at`
      - `spawn_monster`
    - Placing items
      - Randomly-spawned items
        - `spawn::fill_room_with_spawns`
        - `fill_room_with_spawns`
        - `spawn_random_item_at`
        - Item-spawning functions:
          - `spawn_weapon`
          - `spawn_armor`
          - `spawn_health_potion`
          - `spawn_magic_missile_scroll`
          - `spawn_fireball_scroll`
          - `spawn_sleep_scroll`
        - `spawn_item` helper function
      - Guaranteed ration (`spawn_guaranteed_ration`)
      - Guaranteed equipment (`spawn_guaranteed_equipment`)
        - Starting equipment (hard-coded)
        - Periodic equipment
          - Periodic weapon RNG seeding
            - Idea: Give every set of four levels the same RNG seed, roll a number from 0 to 2 and spawn weapon in that level of the set.
            - 0-2 vs. 0-3 to guarantee a gap level.
            - Use low bits of game seed to shift the offset.
          - Periodic armor RNG seeding is the same, but shifts with the high bits of the game seed instead.
  - *Auto-run*
    - Most of the time playing RuggRogue is spent moving from place to place.
    - Instead of repeatedly pressing movement keys, the player can tell the game to move in a direction until something interesting is seen.
    - This feature is known as *auto-running*.
    - Auto-Run Basics
      - Integrated to act like real player inputs with additional checks to interrupt it, e.g. monster appears or player presses a key.
      - Hold shift and press movement key to auto-run in that direction.
      - Three kinds of auto-run:
        1. *Rest in place*: Shift+Space to rest until fully healed.
        2. *Straight auto-run*: Shift+direction in open space or against a wall on one side to move in one direction until terrain changes.
        3. *Corridor auto-run*: Shift+direction in a corridor to follow the corridor until it branches or opens up.
      - Once auto-run starts it issues movement commands until interrupted by:
        - the player presses a key
        - a monster appears in the player's field of view
        - the player moves next to an item or downstairs tile
    - Auto-Run Data Structures
      - `auto_run` field in `Player` struct in `src/components.rs`
      - `AutoRun` struct in `src/player.rs`
      - `AutoRunType` enum in `src/player.rs`
      - `AutoRunWallSide` enum in `src/player.rs`
    - Automatic Inputs
      - If Shift is held when a movement key is pressed, the turn is mostly handled as usual, but `auto_run` in `Player` is set to begin auto-running process.
      - `player_input` fn in `src/player.rs`
        - checks for interruption from key press, adjacent items or stairs or enemies in sight
        - decrements `auto_run.limit` and stops auto-running when it reaches zero
        - calls `auto_run_next_step` fn for next direction to move
        - with a step, calls `try_move_player` or `wait_player` fns like normal player input
        - without a step, stops auto-running
      - bottom of `DungeonMode::update` fn returns `ModeUpdate::Update` if auto-run is active
        - breaks away from game's usual post-update behavior of waiting for an event before updating
        - (include code skeleton here)
    - Resting in Place
      - Detect auto-run input
        - Normal input logic in `player::player_input` fn checks for Shift key, passes it on to `wait_player` fn as `rest_in_place` arg
      - Check that resting in place can start, if not, exit early with message why
      - Start resting in place by setting `auto_run` field of `Player` struct with `run_type` of `AutoRunType::RestInPlace`
      - On next frame, `player::player_input` fn runs auto-run logic instead of normal input logic
      - Check if auto-run should stop for:
        - `AppQuit` event
        - key press
        - any monster in field of view (`player_sees_foes` fn)
        - auto-run turn limit (decremented and checked)
      - Check main auto-run condition with `auto_run_next_step` fn
        - returns `Some(...)` to continue or `None` to stop auto-run
      - If auto-run should stop, call `player_stop_auto_run` fn to unset `auto_run` field of `Player` struct
      - Otherwise, perform one step of auto-run with `wait_player` fn
    - Straight Auto-Run
      - Straight auto-run is triggered with Shift+dir in open space on both sides of their direction of movement, or open space on one side and a closed wall on the other side.
        - Closed walls on both sides should be handled with corridor auto-run logic instead.
        - Straight auto-run stops when the state of walls around the player changes, or the player steps next to items or the downstairs tile.
      - Wall and space checking is handled by `auto_run_straight_check` fn, adjacent tile check is handled by `player_check_frontier` fn, both in `src/player.rs` file.
        - Tiles checked by these functions differs based on the direction the player is moving.
        - The player can move in eight directions, but we don't want to repeat similar code for every direction.
        - Instead, RuggRogue checks tiles for the player moving straight right and diagonally up-right, then *rotates* these logical tiles to match the player's movement direction.
      - Rotating by Movement Direction
        - Rotation in the `auto_run_straight_check` fn starts by reading the player's movement direction into the `run_dx` and `run_dy` variables.
        - `run_dx` and `run_dy` are fed into the `rotate_view` fn to retrieve rotation parameters: `real_x_from_x`, `real_x_from_y`, `real_y_from_x`, `real_y_from_y`.
        - Aside: Consider increases to `y` as up by convention.
        - To rotate, we need to think about how the real map `x` and `y` change when `run_dx` and `run_dy` change.
        - e.g. Rotating logical coordinates 90 degrees anti-clockwise
          - when `run_dx` increases (+1), real map `x` remains stationary (`real_x_from_x` == 0) while real map `y` increases (`real_y_from_x` == 1)
          - when `run_dy` increases (+1), real map `x` decreases (`real_x_from_y` == -1) while real map `y` remains stationary (`real_y_from_y` == 0)
        - (post full table of parameters from `rotate_view` fn here)
        - (post and describe `real_x` and `real_y` helper closures from `auto_run_straight_check` fn here)
      - Checking for Walls and Open Space
        - To decide if straight auto-run should start or continue, the tiles around the player need to be looked at.
        - `auto_run_straight_check` fn does this and returns:
          - `Some(AutoRunWallSide::Left)` == complete wall on left and completely open tiles on right
          - `Some(AutoRunWallSide::Right)` == complete wall on right and completely open tiles on left
          - `Some(AutoRunWallSide::Neither)` == completely open tiles on left and right
          - `None` == anything else, including wall in front
        - (post tiles checked for player moving right; relate `real_x`, `real_y` and possible return values)
        - (post tiles checked for player moving up-right)
      - Checking for Items and Downstairs
        - Auto-run can also stop for items and downstairs; checked with `player_check_frontier` fn.
        - Checks current player position as well as newly-adjacent tiles in the player's movement direction.
        - (post tiles checked for player moving right)
        - (post tiles checked for player moving up-right)
      - Putting It All Together
        - Like resting in place, normal input logic in `player::player_input` fn checks for Shift, but sends result to `try_move_player` fn as `start_run` arg
        - In `try_move_player` fn, run attempt is stopped if any monsters are in the player's field of view.
        - If movement occurred, game decides if corridor auto-run or straight auto-run should begin.
        - If `auto_run_straight_check` fn succeeds, store the `AutoRunType` value returned in the `run_type` field of player's `AutoRun` struct
        - On subsequent frames, continue straight auto-run in the `player::player_input` fn until:
          1. `player_check_frontier` fn finds something next to the player
          2. `auto_run_straight_check` fn (called via `auto_run_next_step` fn) returns a different `AutoRunType` value at the player's current position to the one stored in the `run_type` field
    - Corridor Auto-Run
      - Corridor auto-run follows single-tile-wide corridors until they fork, open up or end.
      - Corridor auto-run is nearly identical to straight auto-run with three key differences:
        1. The check to start or continue auto-running is performed by the `auto_run_corridor_check` fn instead of the `auto_run_straight_check` fn.
        2. The `auto_run_corridor_check` fn returns the direction of the next step along the corridor instead of the state of surrounding walls and open spaces.
        3. The auto-run direction is constantly *updated* to follow the corridor.
      - The `auto_run_corridor_check` fn takes the player's movement direction, checks surrounding tiles and returns `Some((dx, dy))`, the dir of the next step
      - The player's corridor auto-run direction is updated at each step in the `auto_run_next_step` fn.
      - The `auto_run_corridor_check` fn rotates the tiles it checks to the player's movement direction with the help of the `rotate_view` fn, much like the `auto_run_straight_check` fn.
        - Also used to rotate the returned direction of the next corridor auto-run step.
      - Tiles around the player are checked for walls.
        - The tiles chosen depend on the player's movement direction.
        - Each wall sets an individual bit in a 16-bit unsigned integer variable named `nearby_walls`.
      - The bits of the `nearby_walls` variable are matched against patterns of wall and non-wall tiles stored in tables.
        - A successful match returns the next direction for corridor auto-run to follow, adjusted for rotation.
        - There are separate tables for the player moving right and up-right; rotation collapses all other directions into just those two.
      - (Provide simplified 8-bit example of pattern matching using first case after cardinal player move.)
      - (List basic cardinal patterns here.)
        - Wants one open tile with a 90-degree change in direction at most.
        - That one open tile must have walls on both sides.
      - (List cardinal corner patterns here.)
        - Corridor corners put two open tiles next to the player instead of one.
        - Needs to check some tiles two steps away from the player; treat unseen tiles like walls for testing purposes.
        - Player can step into either open tile; game chooses to step into the corner instead of cutting the corner.
      - (List basic diagonal patterns here.)
      - (List diagonal corner patterns here.)
    - Interrupting Auto-Run for Hunger
      - The game has a hunger mechanic where the player gets hungry over time and must eat to ward it off.
      - Hunger level is shown in the side bar, e.g. "Full", "Normal", "Hungry", "Very Hungry", "Famished" or "Starving".
        - Auto-run stops when hunger drops from one level to another below "Normal", e.g. "Normal" to "Hungry" or "Hungry" to "Very Hungry".
      - When player's hunger level is "Starving" they'll periodically lose hit points, which also stops auto-run.
      - All of this happens in the `hunger::tick_hunger` fn in the `src/hunger.rs` file.
  - *Turn order and combat*
    - The structure of `DungeonMode::update` and the `time_passed` variable.
    - `MonsterTurns`, `monster::enqueue_monster_turns` and `monster::do_monster_turns`.
    - `damage::melee_attack` and the damage formula.
    - `damage::handle_dead_entities`
      - Monster death
      - Player death, the `PlayerAlive` flag and moving from `DungeonMode` to `GameOverMode`.
  - *Items*
    - List of items:
      - Present (`spawn_present`)
      - Ration (`spawn_ration`)
      - Health Potion (`spawn_health_potion`)
      - Magic Missile Scroll (`spawn_magic_missile_scroll`)
      - Fireball Scroll (`spawn_fireball_scroll`)
      - Sleep Scroll (`spawn_sleep_scroll`)
      - Weapon (`spawn_weapon`)
      - Armor (`spawn_armor`)
    - Spawning Items
      - Randomly in 25% of rooms (`spawn_random_item_at`):
        - 1/11 - weapon or armor with extra +1 to +3 power bonus
        - 3/11 - Health Potion
        - 3/11 - Magic Missile Scroll
        - 2/11 - Fireball Scroll
        - 2/11 - Sleep Scroll
      - One Ration per level
      - Depth-appropriate weapon and armor at irregular intervals
      - Starting weapon and armor
      - See "Map Population" chapter for details.
    - Inventory and Equipment
      - `Inventory` and `Item` components
      - `Equipment` and `EquipSlot` components
      - Inventory Screen and Item Actions
        - `InventoryMode` and `InventoryActionMode`
        - `TargetMode` if item needs ranged target tile
        - Only lets the player pick an item and an action; effects are handled by `DungeonMode::update`
        - Shortcut keys
      - Shortcut Menus
        - `InventoryShortcutMode` and `EquipmentShortcutMode`
        - `InventoryAction` enum in `src/modes/inventory_action.rs`
      - Menu Memory
        - Menu positions remembered in `MenuMemory` struct in `src/menu_memory.rs`
        - `PickUpMenuMode` memory is reset if brought up at different map coordinates
    - Picking Up Items
      - `player::player_pick_up_item`
      - `item::remove_item_from_map`
      - `item::add_item_to_inventory`
    - Dropping Items
      - `player::player_drop_item`
      - `item::remove_item_from_inventory`
      - `item::add_item_to_map`
      - `item::drop_equipment` for equipment
    - Equipping Weapons and Armor
      - `item::equip_item`
      - `item::remove_item_from_inventory`
    - Using Items
      - `item::use_item` fn in `src/item.rs`
      - Victory
        - `GameOverMode` but player is alive so it's a win screen
      - Picking a Target
        - Self targeting vs. ranged
          - Ranged items have a target tile chosen for them by `TargetMode` in advance
        - Area of effect
        - Reusing field of view for valid target tile and area of effect
          - Area of effect preview ignores it to hide unseen terrain, but actual effect considers it
      - Effects
        - Effects apply to all targets
        - Nutrition
        - Healing
        - Damage
        - Sleep
          - `Asleep` component
          - `item::handle_sleep_turn`
            - Called by `player::player_input`; most keys except menu (Esc) pass a turn
            - Called by `do_turn_for_one_monster` in `src/monster.rs` for sleeping monsters
          - Sleep counter decrements:
            - -1 per turn
            - -1 if player can see the monster or vice versa
            - -10 if hit points were lost since the last turn
  - *Hunger and regeneration*
    - RuggRogue has a hunger mechanic: player gradually regens HP while well-fed, but loses HP while starving.
    - Player becomes hungrier with the passage of time, but can eat rations found on each level to ward it off.
    - Hunger mechanic rewards the player for exploring to find rations and acts as pressure to keep the player moving lest they starve.
    - Stomach and Nutrition
      - `Stomach` and `Nutrition` components
      - Eating Rations in `item::use_item` fn in `src/item.rs`
    - Hunger States
      - `HungerState` component
      - Conversion from `Stomach` fullness for visible hunger effects
      - Discrete hunger levels
    - Sidebar Hunger Display
      - `hunger::player_hunger_label` fn called from `draw_status` fn in `src/ui.rs` file
    - Regeneration and Starvation
      - Per-turn effects: `hunger::tick_hunger` fn called from `DungeonMode::update` in `src/modes/dungeon.rs` file.
      - Regeneration: `HungerState::turns_to_regen_to_max_hp`
      - Starvation: `HungerState::turns_to_starve_from_max_hp`
      - Explain `sub_hp` field of `Stomach` component, with examples
      - Implication: higher max HP means faster regen.
    - Hunger Messages
      - Hunger state changes provoke a message saying as much.
      - Message composed with `HungerState::reduced_to` fn.
    - Effects of Hunger on Auto-Run
      - Stomach must be full enough to start waiting in place: `hunger::can_regen` fn checked in `wait_player` fn in `src/player.rs` file.
      - Stomach must be full enough to continue waiting in place: same fn consulted in `auto_run_next_step` fn in `src/player.rs` file.
      - Getting a hunger message in `hunger::tick_hunger` fn interrupts all forms of auto-run.
      - Losing HP due to hunger interrupts all forms of auto-run.
  - *Experience and difficulty progression*
    - Combat between player and monsters are at the core of RuggRogue.
    - Damage formula from Turn Order and Combat chapter not enough; needs firm numbers e.g. HP/att/def for player/monsters.
    - Numbers need to be picked to answer questions like "how many hits are needed for player to kill monster at equal level?"
    - Another problem: As player kills monsters they grow more powerful; how does the game avoid becoming easier over time?
    - Game Balance
      - `level_factor` fn in `src/experience.rs`; don't use level directly!
        - `experience::calc_player_max_hp`
        - `experience::calc_player_attack`
        - `experience::calc_player_defense`
        - `experience::calc_monster_max_hp`
        - `experience::calc_monster_attack`
        - `experience::calc_monster_defense`
        - `experience::calc_monster_exp`
        - `experience::calc_weapon_attack`
        - `experience::calc_armor_defense`
      - Establishes *numeric relationships* between equal-level player/equipment/monsters, e.g.:
        - Player attack: p.atk. (4.8) + wep (3.2) = 8.0 vs. m.def. (4.0) does 4.0 dmg (re. damage formula) to m.hp. 14, killing it in 3.5 hits
        - Monster attack: m.atk. (8.0) vs p.def. (2.4) + arm (1.6) = 4.0 does 4.0 dmg to p.hp. 40, killing them in 10 hits
    - Player Experience
      - `Experience` component in `src/components.rs`
        - `base` + `next` fields is experience number in sidebar
        - Player is spawned at level 1 with 50 exp pts to next level in `spawn::spawn_player` fn in `src/spawn.rs`
      - `GivesExperience` component attached to monster entities
      - On player attack `HurtBy` component credits player for damaging monster in `damage::melee_attack` fn in `src/damage.rs`
      - When monster dies, `damage::handle_dead_entities` fn in `src/damage.rs` awards exp set in `GivesExperience` to player's `Experience`
    - Gaining Levels
      - Experience pts checked when `DungeonMode::update` in `src/modes/dungeon.rs` calls `experience::gain_levels` fn in `src/experience.rs`
      - `experience::gain_levels` fn raises experience level if `exp` field of `Experience` component reaches `next` field
      - Each level requires 10% more experience pts
      - If entity has `CombatStats` component, Attack, defense and hit points recalculated for the new level
        - Hit point gain is calculated specially to preserve any max hit points gained from health potions
      - Finally, player level gain logs a message saying so.
    - Difficulty Tracker
      - If player gained power from experience levels while dungeon stayed the same, the game would get easier over time!
      - Game needs to increase the level of monsters over time to counteract this, but at what rate?
        - Too slow: Still gets easier over time.
        - Too fast: Player will be overwhelmed.
      - Solution: Difficulty Tracker entity
        - Gains experience and levels, but has no `CombatStats` component
          - Created by the `spawn::spawn_difficulty` fn in `src/spawn.rs`
        - Gains experience slightly differently to the player:
          - After map population, `experience::calc_exp_for_next_depth` fn in `src/experience.rs` is called
            - Counts all experience that every monster on the map can grant and saves it to `exp_for_next_depth` field of `Difficulty` unique
          - When player descends, experience in `exp_for_next_depth` is given to difficulty tracker and any levels gained via `experience::gain_levels` fn
      - The level of the difficulty tracker decides:
        - Max level of monsters to spawn
        - Base power level of weapons and armor spawned
      - Experience between levels act like partial levels
        - `Difficulty::get_round_random` and `Difficulty::as_f32` fns
        - `experience::f32_round_random` helper fn
    - Monster Selection
      - Names and appearances for monsters are defined in the `MONSTERS` array in `src/spawn.rs`
      - `spawn_random_monster_at` fn in `src/spawn.rs` picks from `MONSTERS` array based on difficulty tracker level
        - 20% for level-matching monster
        - 40% for monster 1 to 3 levels lower
        - 40% for an even lower level monster
      - `spawn_monster` fn is called to create the monster with the right numbers for the desired level:
        - `experience::calc_monster_max_hp`
        - `experience::calc_monster_attack`
        - `experience::calc_monster_defense`
        - `experience::calc_monster_exp`
    - Weapon and Armor Selection
      - Power level of randomly-spawned weapons and armor decided by `spawn_random_item_at` fn in `src/spawn.rs`
        - Base power decided by difficulty tracker level, but also gets a random +1 to +3 bonus
      - `spawn_weapon` fn in `src/spawn.rs` picks a weapon name and appearance from `WEAPONS` array in same file
        - Name and appearance picked according to *base* level determined from the difficulty tracker, not counting random bonus
        - `spawn_armor` fn does the same thing using the `ARMORS` array instead
    - Picking the Final Dungeon Level
      - The `MONSTERS` array has 25 different monster names and appearances
      - Once the difficulty tracker has allowed them all to spawn, the player has no new monsters to see
      - `map::generate_rooms_and_corridors` fn in `src/map.rs` checks if difficulty tracker level has reached 25
        - If so, downstairs is replaced with the location to place the victory item that ends the game.
  - *New game plus*
    - How New Game Plus plays
      - After the player wins the game, they're fully healed and placed into the top of a fresh dungeon.
      - They get to keep their level, experience, stats and all of their equipment and items apart from the victory item.
      - The game will allow more monsters and items to spawn for each successive win.
      - The power of weapons and armor spawned will continue to increase from the end of the last game.
      - Intended to be a victory lap to collect ever more powerful equipment and not a proper challenge.
    - New Game versus New Game Plus
      - Game over sequence
        - `GameOverMode::update` fn in `src/modes/game_over.rs`
        - `title::post_game_cleanup` and `title::new_game_setup` fns in `src/modes/title.rs`
          - Carrying over the player entity
    - Win Counter
      - `Wins` unique
      - Shown on the game over screen from the second victory onward.
      - Increases maximum number of items and monsters spawned per room by one.
        - `fill_room_with_spawns` fn in `src/spawn.rs`
    - Base Equipment Level
      - New Game Plus needs to continue increasing the power of weapons and armor, but `title::new_game_setup` fn always resets difficulty tracker.
      - `BaseEquipmentLevel` unique
        - Remembers the level of the difficulty tracker at the end of the last game and adds it to spawned weapons and armor in the next.
  - *Options*
    - Player can bring up *options dialog* by pressing Esc key during play or choosing "Options" at the title screen.
    - Allows player the choice of UI font, tiles or ASCII for the main play area, and 1x or 2x zoom for both of these display elements.
    - Options Data
      - `Options` struct in `src/ui.rs`
      - Default options set in `main` fn in `src/main.rs`
      - The meaning of tileset indices (`tileset_infos` field in `RunSettings` set in `main` fn)
        - Fonts come before tilesets
    - Options Dialog
      - `OptionsMenuMode` in `src/modes/options_menu.rs`
      - Shows "Save and Exit" if brought up during play via `prompt_to_save` arg sent to `Options::new` fn
      - Fields of `Options` struct modified by `OptionMenuMode::update` fn
      - `NUM_FONTS` constant limits font choice to font-like tilesets at the beginning of the list of tilesets
    - Real-Time Options Updates
      - Rendering system directly consults option values so they'll update in real time.
      - Recap of concepts from Rendering chapter:
        - Displayed tile grid
        - `TileGridView`
        - GPU-side tile grid texture
        - CPU-side tile grid pixel buffer
        - `tileset_index` field of `TileGrid`
        - tile data of `TileGrid`
      - Dependencies:
        - Displayed tile grid: `TileGridView` + texture
        - texture: pixel buffer
        - pixel buffer: `tileset_index` + tile data
      - Changes to tileset and font in Options dialog affect `tileset_index`
        - Invalidates pixel buffer -> texture -> displayed tile grid
        - `TileGrid::set_tileset` fn in `src/lib/tilegrid.rs`
      - Changes to zoom affect `TileGridView` -> displayed tile grid
        - `text_zoom` field of `Options` struct read out directly `prepare_grids` fns of most modes
          - Used to calculate size, position and zoom for `TileGridView` of each `TileGrid`
          - Common case of screen-centered tile grid handled by `TileGrid::view_centered` fn
        - `map_zoom` field read out by `ChunkedMapGrid::prepare_grid` fn in `src/chunked.rs` for the main map grid
