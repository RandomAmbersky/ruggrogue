- **Intro**
  - What is this doc?
  - Who is it for?
  - What does it cover?
- **Dependencies**
  - bitflags
  - bitvec
  - rand, rand\_xoshiro
  - sdl2 (with "image" feature)
  - serde, serde\_json
  - shipyard
  - wyhash
- **Source code layout**
  - It's around 13K SLOC.
  - Most of this won't make sense; see further for context.
  - `assets/` - font and tile images
  - `src/` - game-specific files, quick overview of each file
  - `src/lib/` - game-agnostic files, quick overview of each file
  - `src/modes/` - mode stack implementation and every mode, describe each file starting with mod.rs
- **How stuff works**
  - No engine (unless SDL2 counts) and no roguelike helper libraries.
  - *Overall game flow*
  - *Game loop*
  - *The mode stack*
    - Avoiding the all-encompassing state machine from the Rust roguelike tutorial.
    - ModeResults, or how to handle responses from menus and dialog boxes.
  - *Input queue*
  - *Rendering and display using TileGrids*
    - Overarching rendering strategy
      - Describe software rendering for tile-based graphics.
      - Describe hardware rendering of tile-based graphics with a texture altassing approach.
      - Describe RuggRogue's choice: hybrid rendering.
        - Reasons:
          - Separates drawing tile grid contents from how it's displayed on screen (easier positioning + zoom).
          - Pure SDL-based drawing lets SDL choose the best graphics API for its environment.
        - Probably not the fastest it could be, but it seems reasonably fast compared to naive per-tile drawing.
    - TileGrids and TileGridLayers
      - Everything shown by RuggRogue is a TileGrid.
      - Main game loop inits and draws TileGridLayers; essentially a scene graph.
      - Mode stack ensures that each mode gets its own fresh TileGridLayer.
      - Modes can create as many TileGrids as they need within their TileGridLayer.
    - Tilesets: black-and-white conversion, tall vertical surface for cache-friendliness during rendering.
    - The phases of drawing: draw, render, upload, display.
      - Draw: The TileGrid drawing API, implementations mostly passed off to RawTileGrid.
      - Render: Check for changed tiles with RawTileGrids, draw changed tiles.
      - Upload: Single SDL call to do this.
      - Display: Each TileGrid copies itself to the canvas, while main game loop uses SDL to present it all.
    - Improving render performance with wrapped offset rendering.
    - Improving map draw performance with chunked drawing.
  - *User interface*
    - Mode breakdown with YesNoDialogMode as an example.
    - Layout and drawing of the main game screen.
    - The AppQuit event.
  - *Word wrapping*
  - *Entity Component System*
    - How Shipyard is used.
    - RuggRogue uses Shipyard 0.4:
      - Couldn't use Shipyard 0.5 since a transitive dependency broke the web build.
      - 0.4 API differs from 0.5, so it needs to be covered, since 0.4 docs are no longer online.
    - The World
      - Worlds hold uniques and entities with attached components.
      - Creating a world: `World::new`
    - Uniques
      - What is a unique?
      - Adding a unique to the world: `World::add_unique`
      - Accessing uniques: `UniqueView` and `UniqueViewMut`, with examples using `World::borrow`
      - Shipyard 0.4 has no way to delete or replace uniques.
    - Entities and Components
      - What are entities and components?
      - Creating entities: `EntitiesViewMut` and `EntitiesViewMut::add_entity`
      - Removing entities: `AllStoragesViewMut` and `AllStoragesViewMut::delete`
      - Adding components to entities: `EntitiesView` and `EntitiesView::add_component`
      - Deleting components from entities: `ViewMut::delete`
      - Accessing components of a single entity: `View` and `ViewMut` with the `Shipyard::Get` trait
      - Iterating entities that share components: `Shipyard::IntoIter::iter` and `Shipyard::Shiperator::with_id`
      - Using `EntityId` as a handle to an entity
      - Checking if an entity has a component: `View::contains` and `View::try_get`
    - Avoiding systems
      - `World::run` sometimes appears instead of `World::borrow`
      - RuggRogue prefers `World::borrow` for fine-grained control over references.
        - Rust: One mutable reference or multiple immutable references only.
          - Why it helps: data consistency, use screen tearing as an analogy.
      - Shipyard grants references and checks rules at runtime.
        - Lifetimes of most game data depends on player actions, so many of these checks must be at runtime.
          - Leaf functions still use Rust's compile-time checking.
      - Problem: can't `World::run` within `World::run`.
      - Problem: calling a system within a system, using simplified player spawning as an example.
      - Problem: views claimed too early, causing helper functions to panic.
      - All of these problems are from calling functions within functions.
        - Personal style.
        - Using Shipyard's *workloads* runs systems without nesting, embracing the full ECS style.
          - Couldn't use workloads because runs multi-threaded only, which doesn't work in the web build.
  - *Game data* (Entity life cycle)
    - The world, and which entities exist and when.
    - Despawning entities, including entities they refer to.
  - *Save and load*
    - Overview of saving and loading in the context of the rest of the game.
    - The save file format, with a simple example.
    - Handling of EntityIds during saving and loading.
    - Run-length encoding, used to compress map tile data and field of view bits.
    - Save support for the web version.
  - *Field of view*
  - *Pathfinding using A-star*
    - Fallback path target, similar to NetHack.
    - Tweaking the heuristic to make monsters line up cardinally with the player.
  - *Random number generator*
    - No global RNG.
    - Instead, hash game seed, input values and magic number to seed termporary RNGs.
    - Makes testing way easier, especially map generation (used to fix diff map gen between native vs. web).
  - *Map generation*
    - Prim's algorithm for connecting rooms.
    - Monster and item spawning.
    - Place downstairs or spawn victory item?
  - *Auto-run*
    - Idea: rotate world, check tiles, pick direction, unrotate world.
    - Checked tile patterns are hard-coded, but work well in practice.
    - Integrated to act like real player inputs with additional checks to interrupt it, e.g. monster appears or player presses a key.
  - *Turn order and combat*
    - The damage formula.
    - Avoiding zero damage using tanh.
  - *Items*
  - *Hunger and regeneration*
    - Stomach component and the basics of hunger: ticks down over time, fills when eating, regen when above threshold, starving when zero.
    - Sub-HP and turns to regen to max HP.
    - Implication: higher max HP means faster regen.
  - *Experience and difficulty progression*
    - Experience formula
    - The level factor, which determines everything else.
    - The difficulty tracker, which determines the spawn level of monsters and equipment.
  - *New game plus*
    - Increases monster and item spawns in rooms per win.
    - Resetting difficulty, but still spawning more powerful equipment.
    - Safety save before using victory item, and why.
