- **Intro**
  - What is this doc?
  - Who is it for?
  - What does it cover?
- **Dependencies**
  - bitflags
  - bitvec
  - rand, rand\_xoshiro
  - sdl2 (with "image" feature)
  - serde, serde\_json
  - shipyard
  - wyhash
- **Source code layout**
  - It's around 13K SLOC.
  - Most of this won't make sense; see further for context.
  - `assets/` - font and tile images
  - `src/` - game-specific files, quick overview of each file
  - `src/lib/` - game-agnostic files, quick overview of each file
  - `src/modes/` - mode stack implementation and every mode, describe each file starting with mod.rs
- **How stuff works**
  - No engine (unless SDL2 counts) and no roguelike helper libraries.
  - *Overall game flow*
  - *Game loop*
  - *The mode stack*
    - Avoiding the all-encompassing state machine from the Rust roguelike tutorial.
    - ModeResults, or how to handle responses from menus and dialog boxes.
  - *Input queue*
  - *Rendering and display using TileGrids*
    - Overarching rendering strategy
      - Describe software rendering for tile-based graphics.
      - Describe hardware rendering of tile-based graphics with a texture altassing approach.
      - Describe RuggRogue's choice: hybrid rendering.
        - Reasons:
          - Separates drawing tile grid contents from how it's displayed on screen (easier positioning + zoom).
          - Pure SDL-based drawing lets SDL choose the best graphics API for its environment.
        - Probably not the fastest it could be, but it seems reasonably fast compared to naive per-tile drawing.
    - TileGrids and TileGridLayers
      - Everything shown by RuggRogue is a TileGrid.
      - Main game loop inits and draws TileGridLayers; essentially a scene graph.
      - Mode stack ensures that each mode gets its own fresh TileGridLayer.
      - Modes can create as many TileGrids as they need within their TileGridLayer.
    - Tilesets: black-and-white conversion, tall vertical surface for cache-friendliness during rendering.
    - The phases of drawing: draw, render, upload, display.
      - Draw: The TileGrid drawing API, implementations mostly passed off to RawTileGrid.
      - Render: Check for changed tiles with RawTileGrids, draw changed tiles.
      - Upload: Single SDL call to do this.
      - Display: Each TileGrid copies itself to the canvas, while main game loop uses SDL to present it all.
    - Improving render performance with wrapped offset rendering.
    - Improving map draw performance with chunked drawing.
  - *User interface*
    - Keeping controls simple with judicious use of menus.
    - Drawing and handling input for menus and dialogs.
    - Changing graphics and zoom options in real-time.
    - Inventory and equipment shortcut menus.
  - *Word wrapping*
  - *Managing data* (Entity life cycle)
    - The world, and which entities exist and when.
    - Despawning entities, including entities they refer to.
  - *Save and load*
    - The data to save: uniques and components.
    - The save file format.
    - Handling of EntityIds during saving and loading.
    - Run-length encoding, used to compress map tile data and field of view bits.
  - *Field of view*
  - *Pathfinding using A-star*
    - Fallback path target, similar to NetHack.
    - Tweaking the heuristic to make monsters line up cardinally with the player.
  - *Random number generator*
    - No global RNG.
    - Instead, hash game seed, input values and magic number to seed termporary RNGs.
    - Makes testing way easier, especially map generation (used to fix diff map gen between native vs. web).
  - *Map generation*
    - Prim's algorithm for connecting rooms.
    - Monster and item spawning.
    - Place downstairs or spawn victory item?
  - *Auto-run*
    - Idea: rotate world, check tiles, pick direction, unrotate world.
    - Checked tile patterns are hard-coded, but work well in practice.
    - Integrated to act like real player inputs with additional checks to interrupt it, e.g. monster appears or player presses a key.
  - *Turn order and combat*
    - The damage formula.
    - Avoiding zero damage using tanh.
  - *Items*
  - *Hunger and regeneration*
    - Stomach component and the basics of hunger: ticks down over time, fills when eating, regen when above threshold, starving when zero.
    - Sub-HP and turns to regen to max HP.
    - Implication: higher max HP means faster regen.
  - *Experience and difficulty progression*
    - Experience formula
    - The level factor, which determines everything else.
    - The difficulty tracker, which determines the spawn level of monsters and equipment.
  - *New game plus*
    - Increases monster and item spawns in rooms per win.
    - Resetting difficulty, but still spawning more powerful equipment.
    - Safety save before using victory item, and why.
